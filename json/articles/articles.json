{
    "articles": [
        {
            "id": "1",
            "title": "赛博SRM",
            "content": "能以二阶段推进的方式发射一大簇高速动能穿刺弹头，这些弹头不仅能极大地削弱护盾，在击中船体时也能产生不俗的EMP 效果。最致命的是，普通点防武器对赛博来说几乎毫无作用。\n作为近程二级动能武器。当一级制导导弹携带着二级动能弹头到达攻击距离时，内置计算机将会顺势点燃动能弹头的推进器，正如其名，赛博所使用的二级弹头是由贫铀之类的高密度金属所制成的尾翼稳定脱壳穿甲弹。\n虽非常适合用于打击敌舰护盾并使其反应堆超载，但由于如今的标准装甲均有间隔，如果目标及时关闭护盾并以这些致密的装甲来承受穿刺弹头的打击时，其造成的破坏力将大幅降低。\n该武器系统装载有数枚赛博导弹。也具有双发和发射舱版本。（小型导弹武器，反护盾，动能，1200）",
            "author": "柚子",
            "tag": "远行星号",
            "year": "2023",
            "time": "10-21 11:45:14",
            "pinned": false
        },
        {
            "id": "2",
            "title": "典范-级 (战列舰)",
            "content": "人之领战舰设计中的巅峰之作，不仅仅是军事上的必要性而造就了该主力舰的诞生，更多的是海军部某些高层军官的野心在速子科技以及主要承包商的大力支持下所带来的结果。\n没有任何一艘主力舰要比典范-级更加坚挺、强大，它是旧时代真正意义上的无敌巨舰。\n战斗性能\n结构值18000\n装甲值1500\n防御方式全盾\n护盾角度360\n护盾维持（幅能\/秒）750\n护盾效率（幅能\/伤害）0.6\n幅能容量25000\n幅能耗散1250\n最高航速30\n战术系统：堡垒护盾\n禁用所有武器来大幅度降低护盾所受到的伤害，但会持续产生硬幅能。\n安装槽位2中型通用，4×小型导弹，4×中型能量，1大型能量，9×小型能量\n",
            "author": "柚子",
            "tag": "远行星号",
            "year": "2023",
            "time": "10-22 19:08:10",
            "img1": "..\/..\/img\/典范.png",
            "pinned": false
        },
        {
            "id": "3",
            "title": "《创世记·第一天》",
            "content": "写给傻蝎：\n你真的好傻好傻啊！\n我不知道，那天夜晚我花了多大的力气才叫出你的名字。看你回头的那一刻，我很茫然，也很犹豫，更不知所措\n，但，我看你笑了。也许你未注意到，但你的笑给予了我勇气，之前的怀疑啊，悔恨啊，自卑啊，在你的笑下都瓦解了呢。\n我看到你站在牌子前等着我。于是，我又跟你肩并肩走在一起了呢，虽然很短暂，但那感觉很美好。这是第三次了，既然过了三，我想会有更多次吧。\n其实我还是有点生气的，你知道吗？我记得之前你站在我旁边傻傻地站了半分钟，还傻傻地问：“王先生坐哪？”（是在问我吗？）希望我不是在自作多情，我真应该告诉你，或是一把从你手中夺过那本子扔在王先生位置上。但我没有，我真怂。那天下午大课间时，我偶然发现你看到我在排队时竟去了另一个餐厅。我想，也许你生气了呢。\n你有因我而受到心灵煎熬了吗？如果有，我既有点高兴，又有点愧疚，原来，你心里有我呢。\n那天你内心慌极了呢。哈哈，你为什么去男寝呢?校门又不在那边~在截然不同的方向呢。你呀，总是这样，装作自己冷冷，满不在乎的，其实心里小鹿乱撞，都不知道自己在干什么，说不定腿又软了呢~\n你说，说你不要我了，鬼才信呢，你最爱撒这种谎了，而且你又笑了，一点都不严肃。虽然我没听清你之前说的那些话，但，我相信未来。\n我再也无需自责，无需自卑，我一定要珍惜你，留住你，你是上天赐给我的幸运。\n 过去的不快终究如轻烟般散去，未来的大门等着我叩起。\n",
            "content_eng": "Written for Silly Scorpion:\nYou are really silly, so silly! \nI don't know how much effort it took me to call out your name on that night. When you turned around, I was confused, hesitant, and at a loss, but I saw you smile. Maybe you didn't notice, but your smile gave me courage and dissipated all my doubts, regrets, and insecurities. I saw you waiting for me in front of the sign, and we walked together shoulder to shoulder again, albeit briefly. It felt wonderful. This is the third time, and since we've passed three times, I think there will be more.\nActually, I was a little angry, you know? I remember you stood next to me stupidly for half a minute and asked, \"Where does Mr. Wang sit?\" (Were you asking me?) I hope I'm not being presumptuous, but I really should have told you or snatched the notebook from your hand and thrown it onto Mr. Wang's seat. But I didn't. I was really cowardly. During the big break that afternoon, I accidentally saw you go to another cafeteria when you saw me lining up. I thought maybe you were angry.\nHave you suffered any mental anguish because of me? If so, I'm both happy and guilty. So, you have me in your heart.\nYou were so flustered that day. Haha, why did you go to the boys' dormitory? The school gate is not over there~ It's in the completely opposite direction. You always pretend to be cold and indifferent, but your heart is in turmoil, and you don't know what you're doing. Maybe your legs even got weak~\nYou said you didn't want me, who would believe that? You love telling lies like that, and you smiled again, not serious at all. Although I didn't hear what you said before, I believe in the future.\nI no longer need to blame or belittle myself. I must cherish you and keep you. You are the luck that God has given me.\nThe unhappiness of the past will eventually dissipate like light smoke, and the door to the future is waiting for me to knock on it.\n",
            "content_jap": "馬鹿なサソリへの手紙：\n君は本当に馬鹿で、本当に馬鹿だよね！\nわからない、あの夜、僕が君の名前を呼ぶのにどれだけの力を使ったか。君が振り返る瞬間、僕はとても当惑し、迷い、何をすべきかわからなかったけれども、君が笑った。君は気づかなかったかもしれないけれど、君の笑顔は僕に勇気をくれた。以前の疑念や後悔、自己卑下も、君の笑顔の下で崩れ去ったんだ。\n君が看板の前で僕を待っているのを見た。だから、僕は再び君と肩を並べて歩んだんだ、短いけれども、とても素敵な感覚だった。これが3回目だ、3回も経てばもっとあるだろうと思う。\n実際、僕はちょっと怒っているんだよ、君は知ってる？覚えている、前に君が僕の横に立って馬鹿みたいに半分ぐらい立っていたこと、それから馬鹿みたいに聞いてきたこと、「ワン先生はどこに座るんですか？」（それって僕に聞いてるのかな？）自分が妄想にふけっているわけじゃないことを願うよ、本当は君に言うべきだった、それか君の手からそのノートを奪ってワン先生の席に放り投げるべきだったんだ。でも、僕はそれができなかった、本当に弱腰だったんだ。ある午後の休み時間、偶然君が僕が列に並んでいるのを見て、別の食堂に行ったのを見つけた。考えてみると、君は怒っていたのかもしれないね。\n君は僕のせいで心の中で苦しんでいるのかな？もしそうなら、僕は少し嬉しいけれど、同時に申し訳なくも感じる。原来、君の心の中には僕がいたんだね。\nあの日、君は本当に慌てふためいていたよね。笑、なんで男子寮に行ったのかな？校門はそっちにないのにね〜完全に逆方向だよ。君はいつもそうだね、冷たいような振る舞いをして、何も気にしていないように見せかけて、実際には心の中で小鹿が跳ね回って、何をしているのか分からなくなって、もしかしたら足もすくんでいるかもしれないね〜\n君は言った、「もういらないって言っているんだ、信じる奴なんていないよ」、君は本当にその嘘を吐くのが好きだね、それに君はまた笑っている、まったく真剣な顔じゃない。前に君が言った言葉は聞き取れなかったけれど、僕は未来を信じているよ。\nもう自分を責めることも、自分を卑下することもない、僕は君を大切にし、君を守ることを決意する、君は天から授かった僕の幸運だから。\n過去の不快は最終的に軽い煙のように消え去り、未来の扉が僕を待っている。\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "4-12 00:00:00",
            "pinned": false
        },
        {
            "id": "4",
            "title": "《创世记·第二天》",
            "content": "你回来了呢。\n细细观察你才发现你经常发呆呢。是在想谁呢？\n其实我是应该鼓起勇气，向你打打招呼的。但是我还是很怕，不够自信，对长相更不自信。\n要是你我独自相处的时间再多一点就好了。\n你也是很闷骚，如果你哪怕积极那么一点点，我也会轻松很多。但，谁叫你是女孩子呢？你也有你的矜持吧。\n",
            "content_eng": "You're back.\nUpon closer observation, I noticed that you often space out. Who are you thinking about?\nActually, I should gather the courage to greet you. But I'm still afraid, lacking in confidence, especially when it comes to my appearance.\nIf only we had more time alone together.\nYou're also quite reserved. If you were even just a little more outgoing, it would make things much easier for me. But well, you're a girl after all, and you have your own sense of propriety.\n",
            "content_jap": "君が帰ってきたね。\nよく見ると、君はよくぼんやりしているんだね。誰のことを考えているのかな？\n実は、僕は勇気を振り絞って、君に挨拶をするべきだったんだ。でも、まだ怖くて、自信が足りなくて、特に容姿に自信がないんだ。\n君とふたりきりで過ごす時間がもう少し多ければいいのに。\n君も結構な内向的なところがある。もし君が少しでも前向きなら、僕も楽になるだろう。でも、君が女の子だからしょうがないね。君も自分の控えめな一面があるんだろう。\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "4-13 00:00:00",
            "pinned": false
        },
        {
            "id": "5",
            "title": "《创世记·第三天》",
            "content": "可能偷偷看你上瘾了吧，细细一想，跟你说说话挺重要，但不是最重要的事，当你转过头来时，我看你，如果你发现了我也看向了我一眼的话，哪怕很短暂，我也会很开心。\n其实我生日快到了呢，你会祝福我吗？还是当作什么都没发生的忘掉呢？我并不衷心于过生日，我只是想看看你的反应，只要有一点反应我也会很开心，如果没有，我会难过，但不会特别在意。\n似乎即使之前在散步的时候，如果我们迎面相行，我总是大大方方地看着你，而你呢，总是低着头，你只敢望我的眼睛望一秒钟，或许只有一眼。其实，咱们第一次散步时，你看着我的眼睛看了蛮久（我当然也在看着你），你说，我们以后还能再散步一次吗？\n真是捉摸不透你这天蝎的心啊，很敏感，很古怪，对于我，你是心虚，还是羞涩呢？\n",
            "content_eng": "Maybe I'm addicted to secretly watching you. Upon further reflection, talking to you is important, but it's not the most important thing. When you turn your head and look at me, even if it's just a brief moment, I feel very happy.\nMy birthday is coming up soon. Will you wish me a happy birthday? Or will you forget about it as if nothing happened? I'm not really that enthusiastic about my birthday, I just want to see your reaction. Even if it's just a small reaction, I'll be very happy. If there isn't any, I'll be sad, but I won't be too bothered by it.\nIt seems that even when we pass each other on our walks, I always look at you straightforwardly, while you always lower your head. You only dare to look into my eyes for a second, maybe just one glance. Actually, during our first walk together, you looked into my eyes for quite a long time (of course, I was also looking at you). You asked, \"Can we go for another walk together in the future?\"\nI really can't figure out your Scorpio heart. You're very sensitive and peculiar. When it comes to me, are you feeling guilty or just shy?\n",
            "content_jap": "僕はこっそりと君を覗いているのかな、よく考えてみると、君と話すことは大切だけど、最も重要なことではない。君が振り向いた時、僕が君を見ているのに気づいて、たとえとても短い時間でも、僕はとても嬉しいんだ。\n実は、僕の誕生日が近づいているんだ。君は祝ってくれるかな？それとも何もなかったかのように忘れるかな？僕は誕生日に深く感じていないんだ、ただ君の反応を見たいだけ。少しでも反応があれば、僕は嬉しい。それがなければ、悲しいけど、特に気にしないだろう。\n散歩中でも、僕たちが向かい合って歩いている時、僕はいつも堂々と君を見つめるけど、君はいつもうつむいている。君は僕の目を見る勇気があって、たぶん一瞬だけど、一瞥することがある。実際、初めて散歩した時、君は僕の目を長い間見ていたよ（もちろん僕も君を見ていた）。君は言った、「また一緒に散歩できるかな？」と。\n君の蠍座の心は本当に読めないね、敏感で奇妙だ。僕に対して、君は臆病なのか、それとも恥ずかしいのか？\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "4-14 00:00:00",
            "pinned": false
        },
        {
            "id": "6",
            "title": "《创世记·第四天》",
            "content": "你又回来了（呵呵……）\n其实你还是给了我几次眼神的（不是我想多），我当然大胆地回敬啦，但你总是不肯多看几眼（我是不是很丑？）\n我将我们的事跟我基友说了，你有向那个朋友提到过我吗？（应该没有吧……）其实这个位置挺好的，至少，你的音容笑貌，一举一动，我可以尽收眼底呢……\n还是想和你说说话呢。（自嘲）\n",
            "content_eng": "You're back again (hehe...)\nActually, you've given me a few glances too (not that I'm overthinking it). Of course, I boldly return them, but you always refuse to look at me for more than a few moments (am I that ugly?).\nI told my best friend about us. Have you mentioned me to your friend? (Probably not...) Actually, this position is quite good. At least, I can see your appearance, your expressions, and your every move...\nStill want to talk to you. (Self-deprecating)\n",
            "content_jap": "また戻ってきたね（ふふ…）。\n実際、君は何度か僕に視線をくれたことがある（多くはないけど）、当然、僕も堂々と返したんだけど、君はいつもそんなに見返してくれない（僕はとても醜いのかな？）。\n僕は友達に君とのことを話したんだけど、君はその友達に僕のことを話したことがある？（多分ないだろうな…）。\nでも、この立場はなかなかいいんだ。少なくとも、君の声や表情、仕草まで、全てを見渡すことができるんだから…\nやっぱり、君と話したいな。（自虐的に）\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "4-15 00:00:00",
            "pinned": false
        },
        {
            "id": "7",
            "title": "《创世记·第五天》",
            "content": "可能态度转变啦。\n我一时很迷惘，我不知道我在追求，追寻什么。我是不是把你看得太重了？其实你一直都在以平常心对我，而我却一直把你看得很重要很重要，看成生命的一倍分。我这样做，似乎只会让自己活得更累。\n我也没必要一直看你，一直看你什么的。王先生说得对，我少多情一点，少忧郁一点，其实可以活得更好。\n也许自作多情的我明天又是另一种态度了。\n",
            "content_eng": "Perhaps my attitude has changed.\nI was confused for a while, unsure of what I was pursuing, what I was searching for. Did I place too much importance on you? In reality, you've always treated me with indifference, while I've considered you incredibly important, as if you were worth twice my life. By doing so, I only make myself more exhausted.\nThere's no need for me to constantly watch you, to obsess over you. Mr. Wang was right, I should be less passionate and less melancholic. I can actually live a better life.\nMaybe tomorrow, this overly sentimental me will have a different attitude again.\n",
            "content_jap": "おそらく態度が変わったんだろうな。\n僕は一時的に混乱していた。自分が何を求め、何を追い求めているのか分からなかった。僕は君をあまりにも重要にしてしまったのかな？実際、君は常に平常心で接してくれているのに、僕はずっと君を非常に重要だと思って、生命の倍の存在だと考えていた。これでは自分をより疲れさせるだけのようだ。\n僕はいつも君を見つめ続ける必要もないし、何もかもを見つめ続ける必要もない。王さんが言うように、もう少し情熱を抑え、少し憂鬱に陥ることなく、実際にはもっと良く生きていけるはずだ。\nもしかしたら、勝手に感傷的になっていた僕も、明日にはまた違った態度になるのかもしれない。\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "4-16 00:00:00",
            "pinned": false
        },
        {
            "id": "8",
            "title": "《创世记·第六天》",
            "content": "一些真心话。\n回忆往事，和你那些往事真的很美好。记得第一次与你聊天时，你就那么随意地将你好朋友的账号发给了我，我很诧异，因为我们完全时陌生人，刚在同个教室一个多星期罢了。\n无论是第一次散步还是第二次散步，我觉得那时的自己很快乐，也很满足，那时看你的眼睛，自己的心灵还是很受震动的。\n后来我们关系恶化时，记得那天你一个人，我叫你时，你止不住地笑。看你的笑和眼角那抹有笑意的眼神，我以为，一切会变好。\n最后还是你亲手删了我吧。我真的像个疯子，你朋友说得对，也许我对你真的动了歪脑筋吧。\n我看来，朋友对你也许并不是负担，而我却不一样，我急于去表达对朋友的那份关心，最后自作自受。对你还是过了火吧。\n今天晚上，在操场上与你相遇，我觉得自己是迷惘的，因为，我觉得还是没法轻易放下你啊。\n你还是很重要，很重要的。如果有一天你孤身一人的走，我觉得我还是会主动上去搭讪。\n",
            "content_eng": "Some sincere words.\nLooking back on the past, those memories with you were truly beautiful. I remember the first time we chatted, you casually shared your friend's account with me, and I was surprised because we were complete strangers, having only been in the same classroom for just over a week.\nWhether it was our first walk or our second, I felt happy and content during those times. When I looked into your eyes, my own soul was deeply moved.\nLater, when our relationship deteriorated, I remember that day when you were alone and couldn't stop laughing when I called out to you. Seeing your smile and the playful gleam in your eyes, I thought everything would get better.\nBut in the end, you deleted me yourself. I truly acted like a mad person. Your friend was right, perhaps I really did develop wrong thoughts about you.\nIt seems that being a friend to you might not be a burden, but I am different. I was eager to express my care for a friend and ended up suffering the consequences. I went overboard with my feelings for you.nTonight, when we met on the playground, I felt lost because I realized I still can't easily let go of you.\nYou are still important, very important. If one day you were walking alone, I think I would still approach you and strike up a conversation.\n",
            "content_jap": "いくつかの真実の言葉。\n過去を振り返り、君との出来事は本当に美しかった。初めて君とチャットした時、君はあんなに気軽に親しい友達のアカウントを教えてくれた。それには驚いたよ。なぜなら、僕たちは完全な見知らぬ人で、同じ教室にいたのはたった1週間余りだったから。\n初めての散歩も、2回目の散歩も、その時の自分はとても幸せで、満足していた。君の目を見ると、心がとても揺れ動いていた。\n後になって関係が悪化した時、覚えている。その日、君は一人でいて、僕が君を呼ぶと、君は止まらないくらい笑っていた。君の笑顔と目元に微かに宿る笑みを見て、僕はすべてが良くなると思った。\n最終的には君が僕を手で削除した。本当に狂ったようだった。君の友達が言った通り、もしかしたら僕は君に対して本当に歪んだ考えを抱いてしまったのかもしれない。\n僕から見れば、友達が君にとっては負担ではないかもしれないけど、僕は違う。僕は友達に気遣いを示そうとして、結局は自滅してしまった。君に対しては火を過ぎたのかもしれない。\n今夜、運動場で君に出会った時、自分が迷惘していると感じた。だって、やはり君を簡単に忘れられないと思ったから。\n君はやはり重要だ、とても重要だ。もしいつか君が一人で歩いている姿を見かけたら、僕はきっと積極的に声をかけるだろう。\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "5-21 00:00:00",
            "pinned": false
        },
        {
            "id": "9",
            "title": "《创世记·第七天》",
            "content": "那天是星期二的夜晚，我心情很不好，特别不好。\n也许我只是在生闷气。也许我是预感到了什么。\n直到，我收到了那封信。\n我以为是你写的。我只觉得自己很迷离，很怅惘，我不知怎得白砖瓦一个个从脚下掠过，我不知怎得迈过一个又一个阶级，终于找到了一个，我认为安全的地方，打开了那封信。我很蒙，但我的第一反应是，你也许欺骗了我呢。\n原来，我跟你做朋友，也会侵犯到别人的权益呢。\n我变得生气很阴沉，我不知怎得变得暴躁。\n那天放学，也许是轮到我收试卷上吧。\n我只觉得自己的脸很硬，很古板，我一声不吭地理着一张又一张试卷，直到，你来了。\n那是我一生不能忘掉的一幕，你拿着试卷，你至始至终在看我，你紧抿着嘴，没说一句话，你将试卷递给我，我知道我脸色不好看难看，但还是很小声地“嗯”了一声。\n你就这样看着我，直到我转头离开。\n我一辈子忘不了你的眼睛，以及镜片上那抹紫光。\n那一夜，灯光很刺眼。\n是她给我的那封信让我很黯淡吧，还有，你那时给我信的身影，微微闭合的双眸，毫不留情的回头，我终于明白，你与我无关。\n我又走上那个阶级，又走去一个无人发现的地方，我打开了那封信。\n很罕见呢，那封信被我撕了。\n我载着夜色，踏着月光，我默然地看着一个个人从我身旁走过，那一夜，灯光好刺眼，好明亮。隐隐约约，我看到你的背影了。\n辣眼。\n也许未来没有机会看到你的背影了吧，但我心甘情愿。\n你的未来我置之不理。\n再见，请忘掉能再见。\n",
            "content_eng": "\nIt was a Tuesday night and I was feeling very bad, especially bad.\nPerhaps I was just sulking. Perhaps I had a premonition of something.\nUntil I received that letter.\nI thought it was from you. I felt disoriented and lost. I didn't know how the white bricks passed under my feet one by one, I didn't know how I stepped over one level after another, until I finally found a safe place and opened that letter. I was confused, but my first reaction was that maybe you had deceived me.\nIt turns out that being friends with you can also violate other people's rights.\nI became angry and sullen, and I don't know how I became irritable.\nThat day after school, maybe it was my turn to collect the test papers.\nI felt that my face was hard and rigid. I silently checked one test paper after another until you came.\nIt was a scene that I will never forget in my life. You were holding the test papers and looking at me from beginning to end. You tightly pursed your lips and didn't say a word. You handed me the test paper, and I knew my face wasn't pretty, but I still murmured \"um.\"\nYou just looked at me until I turned and left.\nI will never forget your eyes in my life, as well as the purple light on the lens.\nThat night, the light was very dazzling.\nIt was probably the letter she gave me that made me feel so bleak, and also the figure of you giving me the letter, the slightly closed eyes, and the merciless turn, I finally understood that you had nothing to do with me.\nI climbed up the steps again and went to a place where no one could find me. I opened that letter.\nIt was rare, I tore up that letter.\nI rode in the night, stepped on the moonlight, silently watching people pass by me one by one. That night, the light was so dazzling and bright. Faintly, I saw your back.\nIt was too bright for my eyes.\nMaybe there will be no chance to see your back in the future, but I am willing.\nI will ignore your future.\nGoodbye, please forget that we can ever meet again.\n",
            "content_jap": "あの日は火曜日の夜で、僕の気分は非常に悪かった。特にひどく悪かった。\nおそらく、ただイライラしていただけかもしれない。おそらく、何かを予感していたのかもしれない。\nそして、その手紙を受け取るまで。\n僕は君が書いたものだと思った。自分がとても混乱していると感じ、足元から白いレンガが一つずつ過ぎ去るのを感じながら、段差を越える方法が分からなかった。最終的には安全だと思われる場所にたどり着き、その手紙を開封した。最初は困惑していたけれど、最初の反応は君が僕を欺いたかもしれないというものだった。\n原来、僕が君と友達になることで、他の人の権利を侵害してしまうことがあるのかもしれない。\n僕は怒りっぽくなり、陰鬱な気分になり、自分がどんどん荒れていくのが分からなくなった。\nその日、放課後、試験の採点が回ってきたのかもしれない。\n自分の顔が硬く、古風であるように感じ、一枚、また一枚と試験用紙を静かに扱い、その時、君が来た。\nそれは僕が一生忘れられない光景だった。君は試験用紙を持っており、最初から最後まで僕を見つめていた。君は口を引き締め、一言も言わずに試験用紙を手渡してくれた。僕は自分の顔色が悪く見苦しいことを知っていたが、それでも小さな声で「うん」と言った。\n君はただ僕を見つめ続け、僕が振り返って去るまで。\n僕は一生忘れられない、君の目と、レンズに映るあの紫色の光。\nその夜、灯りはとても眩しかった。\n彼女がくれた手紙と、君が手紙をくれたときの姿、微かに閉じた瞳、容赦なく背を向ける様子。ついに理解した、君と僕は関係がないと。\n僕はまたあの階段を上り、誰にも気付かれない場所に向かい、その手紙を開封した。\n珍しいことに、その手紙は僕によって破られた。\n夜の色に身を包み、月明かりを踏みしめ、黙って一人ずつ通り過ぎる人々を見つめた。その夜、灯りはとても眩しく、明るかった。ぼんやりと、君の背中を見た。\n目が眩んだ。\nもしかしたら、もう君の背中を見る機会はないかもしれないけれど、僕は喜んでいる。\n君の未来、僕は無視する。\nさようなら。もう再会できないことを忘れてください。\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "6-?? 00:00:00",
            "pinned": false
        },
        {
            "id": "10",
            "title": "蔡年彬精神诊断报告",
            "content": "主诉：患者否认有精神相关疾病。根据同学与朋友的描述，主要是妄想。\n现病史：患者于2018年发病。2018年3月，患者与一个同班女生聊天，一起到操场散步，疑有早恋倾向。两个一开始关系不错，但有一天患者不知道做了什么，同班的女生就断绝了与患者的来往。当同学提起此事时，患者说自己患有“精神分裂”，“都是另一个人格干的”，“我不知道这件事”。可惜无济于事，没有人相信患者说的话。（附注：于2019年同学问起此事时，患者说自己的病好了。另外，双重人格为分离性身份障碍而非精神分裂，可见患者缺乏相关精神病学知识，大概率是谎言。）于2018年5月，患者又与另一同班女生交往，开始在QQ上聊4个小时，并且彼此认可，大有又谈恋爱之势。后因为干了某些出格的事，与其闺蜜发生争吵，再次破碎。在2019年2月下旬，患者由于同班一女生在操场两次散步，第二次被同学们看见并且谣言广为传播。患者在操场散步时，大谈自己与“前女友”（多系2018年5月那个）的事情。后因谣言，该女生断绝与患者的交往，令患者极度伤心，一段时间面无表情，情感淡漠，不太会搭理他人。\n据其朋友叙述，患者在与其同床时，曾说自己的“前女友”水性杨花，很浪，并于自己最好的朋友……并且患者的情绪有些不稳定，有时会面无表情地呆坐着，进入犹如木僵地状态，有时又很兴奋，会滔滔不绝地讲故事。在其“前女友”生日时，患者曾说要返回原校给其一个Surprise，但得知其已考走时又唉声叹气。其同学叙述，患者总爱穿着动物衣物，穿盗版NEW BLANCE鞋，阿拉伯迷彩内裤，并歪头走路等。最近患者地症状有所加重，认为自己可以死灰复燃，在假期期间发QQ消息给2019年2月勾搭地那位女生，但那位女生因为手机掉马桶里并屏蔽了患者而未能回复。返校当天患者写了一封信要求同学转交给那位女生，反应不明。\n既往史：未知患者外伤、输血史，未知病史与服药史、冶游史。\n个人史：略\n家族史：未知\n精神检查\n（一）一般检查：青春期男性，年貌稍显油腻，目光略显深沉忧郁。表情十分丰富，衣着较整齐，但衣品不行。气质也与常人不同，有种把任何衣物穿成大妈衣物地潜质。长相不好描述，在此用同学的话代替：“乱发米饭夹杂，厚唇胡须密布，头戴老年眼镜，身穿大妈服装，下着能遮腿毛裤，足蹬椰子运动鞋，两个鼻孔大如斗，一展歌喉吓死狗”。皮肤较白，激动时面色潮红。意识清楚，定向力完整，完全可以自理，大、小便正常。饮食、睡眠未知。\n（二）认知活动\n1.感知觉：未有错觉、幻觉和感知综合障碍的表现。\n2.思维和思维障碍：据同学及朋友描述，患者有时会非常兴奋、激动，表情丰富，语速较快，笑声诡异，多发在提及患者恋爱史时。在上课、午休、自习时，有时患者会陷入一种类似木僵的状态。当别人叫患者时需若干秒才能反应过来。患者既往可疑出现妄想。当托其朋友问及你是否认为那些女人爱过自己，患者不作答；问及患者是否认为自己很帅，患者不作答。未查及思维连贯性障碍。疑有夸大妄想、钟情妄想。\n3.注意力：有时谈话注意力不够集中，及会不会注意对方的谈话，而进入一种类似木僵的状态。疑似是妄想导致，但也有可能有注意力障碍。\n4.记忆力与智商：从至少上了重点普高来讲，没什么问题。\n5.自知力：否认自己有情绪方面问题，否认自己的问题属于精神方面的，认为自己没有任何精神疾病。患者自认为高深莫测，已经历人间冷暖，懂得爱情，认为同龄人都是不谙世事的小屁孩。其同学大部分不认为其有精神方面的疾病，而认为是他的性格问题。\n（三）情感活动\n可推及患者有情感矛盾，对外宣传自己的“前女友”是个BZ，自己早已放下，不再回头，而自己却想回去见她。但也不排除患者性格原因，比如死要面子。患者对其同学说自己有情感高涨、情感低落、情感淡漠。情感反应与内心活动大都与周围环境一致。\n（四）意志行为：\n在学校时，除了打篮球和与女生散步之外，几乎都是单独一人行动。不在同学多的餐厅吃饭，夜宵时间除了与女生散步的那几次都是独自一人在操场拥挤的人流中行动。患者只要站着都是歪着头的，疑似为作态。患者喜爱带动物的衣物，据其同学描述，有老虎大红鞋、大苍蝇毛衣、大象卫衣、狗熊大衣，还有阿拉伯迷彩内裤。可能有象征性思维。患者有时会十分专注地做一件事，应为妄想，有意志力增强的表现。患者经常专注于学习数学竞赛，但学不起。\n诊断：ICD-11编号7A50.21；7A60.A。有精神分裂症，多次发作，目前为发作期。双向I型障碍，目前为伴有精神病性症状的混合状态。\n治疗计划：\n精神分裂症：当患者出现妄想、瓦解症候群等阳性症状时，服用奥氮平可以有效控制阳性症状。患者之后发病均视为复发，均应视为急性发作期，应尽快控制症状防止疾病所致的继发性伤害。这时应服用奥氮平，5mg\/d开始，如一周后无严重不良反应，应加大剂量至治疗剂量10-20mg\/d。之后到巩固治疗期时，应继续服用治疗剂量至少六个月，待病情充分缓解后，可以减少剂量。但作为第二代抗精神病药，可以根据患者的用药情况、病情程度进行评估，可以在维持治疗期继续使用治疗剂量。当阴性症状发作时，奥氮平效果不佳，可以考虑换药或加药，使用抗抑郁药物。\n双相障碍：躁狂发作时，以心境稳定剂为主，使用碳酸锂。发作时碳酸锂的治疗剂量在100mg-200mg\/d，先从小剂量开始，再逐步增加至治疗剂量。由于奥氮平也有一定的心境稳定作用，所以碳酸锂可作为备用药物，或是和奥氮平联合使用。抑郁发作时，亦可采用碳酸锂。奥氮平与氟西汀也是另一种选择。当上述药物效果均不明显时，可以尝试使用其他抗抑郁药，但要提防其转躁。\n对于这两种疾病，电抽搐治疗也是不错的选择。向其大脑施加233V的电压，并注射麻醉剂和肌肉松弛剂，以免抽搐所致骨折。或者使用热抽搐治疗，不需麻醉剂，可在意识清醒时进行。方法是把患者按在床上，用电熨斗夹击患者头部，即可达到治疗目的。\n",
            "content_eng": "Chief complaint: The patient denies having any mental illness. According to descriptions from classmates and friends, the main issue is delusion.\nPresent medical history: The patient had an onset of symptoms in 2018. In March 2018, the patient chatted with a female classmate and took a walk on the playground, which led to suspicions of early romance. At first, their relationship was good, but one day the female classmate ceased communication with the patient for unknown reasons. When classmates asked about it, the patient claimed to have \"split personality disorder\", saying \"it was another personality that did it,\" and \"I don't know anything about it.\" Unfortunately, no one believed the patient's words. (Note: When asked about this in 2019, the patient said the illness had been cured. Also, dissociative identity disorder rather than schizophrenia is characterized by multiple personalities, indicating that the patient lacks relevant psychiatric knowledge and is probably lying.) In May 2018, the patient started chatting with another female classmate on QQ for four hours and both expressed interest in each other, showing signs of starting a romantic relationship. However, due to some inappropriate behavior, the patient had a falling out with the girl and her best friend, leading to another breakup. In late February 2019, when the patient was taking walks on the playground with another female classmate from the same class, the second time was seen by classmates and rumors spread widely. While walking on the playground, the patient talked a lot about his relationship with his \"ex-girlfriend\" (referring to the girl from May 2018). Due to rumors, the girl ceased communication with the patient, causing extreme sadness, emotionless expression, emotional detachment, and disregard for others for a period of time. \nAccording to the patient's friends, when sharing a bed with them, the patient once said his \"ex-girlfriend\" was promiscuous and had a lot of affairs with his best friend. The patient's mood is somewhat unstable, sometimes sitting motionless and entering a state of stiffness, and sometimes very excited and talking endlessly. On his \"ex-girlfriend's\" birthday, the patient said he wanted to return to the original school to give her a surprise, but sighed after learning she had left. According to his classmates, the patient always likes to wear animal clothes, pirate NEW BLANCE shoes, Arab camouflage underwear, and walks crookedly. Recently, the patient's symptoms have worsened, believing that he can make a comeback, he sent QQ messages to the girl he flirted with in February 2019 during the holiday period, but the girl did not reply because her phone fell into the toilet and blocked the patient. On the day of his return to school, the patient wrote a letter requesting that his classmates deliver it to the girl, but the response was unclear.\nPast medical history: Unknown history of trauma or blood transfusion, unknown medical history and medication history, and no history of drug abuse.\nPersonal history: N\/A\nFamily history: Unknown.\nPsychiatric examination\n(one) General Examination: Adolescent male, with a slightly greasy appearance and somewhat deep and melancholic gaze. His facial expressions are very rich, and his attire is relatively neat, but his sense of style is lacking. His temperament is also different from others, with a potential to turn any clothing into something resembling \"auntie\" wear. It's difficult to describe his appearance, so I'll use a classmate's words instead: \"Messy hair mixed with rice, thick lips and dense beard, wearing old-fashioned glasses, dressed in auntie's clothing, wearing pants that can cover leg hair, and sporting coconut shoes, with two nostrils as big as a fight, scaring dogs when singing.\" His skin is fair, and he flushes when excited. He is conscious, oriented, and fully capable of self-care, with normal urination and defecation. His dietary and sleep habits are unknown.\n(two) Cognitive Activities\n1.Perception: No signs of illusions, hallucinations, or sensory integration disorders.\n2.Thinking and Thought Disorders: According to classmates and friends, the patient can sometimes become extremely excited and animated, with a rapid speech rate, strange laughter, especially when talking about his romantic history. During classes, naptime, and self-study, the patient may sometimes enter a state resembling catatonia. It takes him several seconds to respond when called by others. The patient has previously shown signs of delusion. When asked by his friends whether he thinks those women have loved him, the patient does not respond; when asked if he thinks he is handsome, the patient also does not respond. No evidence of thought coherence disorder was found. There is suspicion of grandiose delusions and erotomania.\n3.Attention: Sometimes lacks concentration during conversations and may not pay attention to the other party, entering a state resembling catatonia. This may be due to delusion but could also indicate attention disorders.\n4.Memory and Intelligence: Generally no issues since attending a prestigious high school.\n5.Self-awareness: Denies having any emotional issues and denies that his problems are related to mental health, believing he does not have any mental illness. The patient believes he is profound and has experienced the ups and downs of life, understands love, and considers his peers to be naive. Most of his classmates do not believe he has any mental health problems, but rather attribute it to his personality.\n(three) Emotional Activities\nIt is evident that the patient experiences emotional conflicts. He publicly declares that his \"ex-girlfriend\" is a certain type of person and that he has already moved on and will not look back, yet he still wants to go back to see her. However, the patient's personality could also contribute to this, such as saving face. The patient tells his classmates that he experiences intense emotions, emotional lows, and emotional indifference. His emotional reactions and inner activities mostly align with his surroundings.\n(four) Volition and Behavior:\nWhile at school, apart from playing basketball and walking with girls, he is almost always alone. He does not eat at crowded restaurants with classmates, and except for a few times walking with girls at night, he is always alone amidst the crowded flow of people on the playground. Whenever he stands, he tilts his head, seemingly for effect. The patient likes to wear clothing with animal motifs. According to his classmates, he has worn tiger-patterned shoes, a large fly-patterned sweater, an elephant-patterned hoodie, a bear-patterned coat, and even Arabian camouflage underwear. This may suggest symbolic thinking. Sometimes, the patient can become very focused on one thing, likely due to delusions, showing enhanced willpower. The patient often focuses on studying for math competitions, although he struggles with it.\nDiagnosis: ICD-11 codes 7A50.21 and 7A60.A. The patient has schizophrenia with multiple relapses, currently in a relapse period. They also have bipolar disorder type I with a mixed state accompanied by psychotic symptoms.\nTreatment plan:\nSchizophrenia: When the patient exhibits positive symptoms such as delusions and disintegration syndrome, taking Olanzapine can effectively control positive symptoms. All subsequent relapses should be treated as acute episodes, and symptoms should be controlled as soon as possible to prevent secondary harm caused by the disease. Olanzapine should be taken starting at 5mg\/day, and if there are no serious adverse reactions after one week, the dosage should be increased to a therapeutic dose of 10-20mg\/day. During the consolidation phase, treatment should continue with the therapeutic dose for at least six months, and the dosage can be reduced after the illness is fully relieved. However, since it is a second-generation antipsychotic drug, it can be evaluated based on the patient's medication status and disease severity, and the therapeutic dose can continue to be used during the maintenance phase. When negative symptoms occur, Olanzapine may be ineffective, and switching or adding medications such as antidepressants can be considered.\nBipolar disorder: For manic episodes, mood stabilizers such as lithium carbonate should be used primarily. The therapeutic dose of lithium carbonate during an episode is between 100mg-200mg\/day, starting from a small dose and gradually increasing to the therapeutic dose. Since Olanzapine also has a certain mood-stabilizing effect, lithium carbonate can be used as a backup medication or in combination with Olanzapine. For depressive episodes, lithium carbonate can also be used, or Olanzapine and Fluoxetine can be used as another option. When the above medications are not effective, other antidepressants can be tried, but caution should be taken to avoid inducing mania.\nFor both disorders, electroconvulsive therapy (ECT) can also be a good choice. Applying 233V of electricity to their brain while injecting anesthesia and muscle relaxants can prevent fractures caused by convulsions. Alternatively, hot shock therapy can be used without anesthesia and while the patient is conscious. The method involves pressing the patient onto the bed and using a hot iron to strike their head to achieve the desired treatment effect.\n",
            "content_jap": "主訴： 患者は精神関連の疾患を否認しています。同級生や友人の説明によれば、主に妄想が見られます。\n現病歴： 患者は2018年に病気になりました。2018年3月、患者はクラスメートの女生と一緒に話したり、散歩に行ったりしており、早恋の傾向があると疑われました。最初は関係が良好でしたが、ある日患者が何かをしたことを知らない内に、同じクラスの女生は患者との交流を断ちました。同級生がこのことを話すと、患者は「分裂症」にかかっていると言い、「別の人格がやったのだ」「私はそのことを知りません」と述べました。残念ながら、誰も患者の言っていることを信じませんでした。（注：2019年に同級生がこのことを尋ねたとき、患者は自分の病気が治ったと言いました。また、二重人格は分離性同一性障害であり、精神分裂症ではないことがわかります。患者は関連する精神医学の知識が不足している可能性が高く、おそらく嘘をついているでしょう。）2018年5月には、患者は別の同級生の女生と交際し、QQで4時間話し、お互いを認め合い、恋愛関係が進展する可能性がありました。しかし、何か過激なことをしてしまい、その友達と口論になり、再び破綻しました。2019年2月下旬には、同じクラスの女生と患者が操場で2回散歩したことがあり、2回目は同級生に見られて噂が広まりました。患者は操場で散歩していると、自分と「元カノ」（主に2018年5月のもの）のことを大いに話しました。その後、噂のためにその女生は患者との交流を断ち、患者は非常に傷心し、しばらくの間感情が鈍く、他人との関わりが少なくなりました。\n友人によると、患者は同じベッドで寝ているとき、「元カノ」は軽率で、浮気をしており、自分の最良の友人とも……。また、患者の感情は不安定であり、時折無表情で座り込んで木のような状態に入ることがあり、時折非常に興奮し、物語を滔々と話すことがあります。また、「元カノ」の誕生日のとき、患者は「サプライズ」をすると言いましたが、彼女が既に学校を去ってしまったことを知ると、がっかりしました。同級生によれば、患者は常に動物の服を着ており、ニセのNEW BALANCEの靴を履き、アラビア迷彩のパンツを穿き、歩くときに頭を傾けるなどしていました。最近、患者の症状は悪化しており、自分が復活できると考え、休暇中に2019年2月にメッセージを送りましたが、彼女は携帯電話をトイレに落とし、患者をブロックしていたため返信できませんでした。学校に戻る日には、患者はその女生に渡す手紙を書きましたが、反応は不明です。\n既往歴： 患者の外傷や輸血の歴史は不明であり、病歴や服薬歴、冶遊歴も不明です。\n個人歴： 略\n家族歴： 不明\n精神検査\n（一）一般的な検査： 青年期の男性で、外見はやや不精づくめで、視線はやや深く沈んでいる。表情は非常に豊かで、服装は整っていますが、センスは乏しい。一般の人とは異なる雰囲気があり、どんな服もおばさんの服に見せかけるポテンシャルがあります。容姿はうまく説明できませんが、同級生の言葉を借りて言います：\"ご飯が混じっている乱れた髪、厚い唇にひげが密に生え、老眼鏡をかけ、大婦人の服を着て、脚毛を隠すパンツをはいて、ココナッツスニーカーを履いて、二つの鼻孔が斗のように大きく、歌声を披露すると犬が怖がって逃げ出す。\" 皮膚は比較的白く、興奮すると顔が紅潮します。意識は明晰で、方向感覚も完全で、自己管理ができます。飲食、睡眠に関する情報は不明。\n（二）認知活動\n感知と知覚： 誤認や幻覚、感知の統合障害の兆候は見られません。\n思考と思考の障害： 同級生や友人の説明によれば、患者は時折非常に興奮し、表情豊かで、話すスピードが速く、笑い声が奇妙で、患者の恋愛歴に触れるとより頻繁に発生します。授業中、昼休み、自習中には、患者は時折木のような状態に陥ります。他人が患者を呼ぶと、数秒かかって反応することがあります。患者は過去に妄想的な症状があった可能性があります。友人が女性が患者を愛したと考えるか尋ねると、患者は答えません。患者が自分をハンサムだと思うか尋ねると、患者は答えません。思考の一貫性の障害は確認されませんでした。誇大妄想や恋愛妄想の可能性があります。\n注意力： 会話中に注意が集中していないことがあり、相手の話に注意を払っていないと、木のような状態に入ることがあります。これは妄想によるものと疑われますが、注意力障害の可能性もあります。\n記憶力と知能： これまでの優れた普通高校での学業に問題はありません。\n自己認識： 感情の問題はないと主張し、自分の問題が精神的なものであるとは認めず、自分には何の精神疾患もないと考えています。患者は自分を深遠で理解されない存在と認識しており、人生の冷暖を経験し、愛情を理解していると述べています。同級生の大半は患者に精神的な問題はないと考え、むしろ性格の問題だと見なしています。\n（三）感情活動\n患者の感情には矛盾があり、外部に対して「元カノ」を売女と宣伝し、自分は既に乗り越えており、もう振り返らないと主張しつつも、彼女に戻りたいと思っている可能性があります。ただし、患者の性格的な要因、たとえば面子を重んじる傾向も排除できません。患者は同級生に対して感情が高まったり低下したり、感情が淡白だと言っています。感情反応と内面の活動はほとんど周囲の環境と一致しています。\n（四）意志行動\n学校ではバスケットボールをするか女の子と散歩する以外は、ほとんど一人で活動しています。同級生が多い食堂では食事をせず、夜食の時間は女の子と散歩する数回を除いて、常に混雑したプレイグラウンドで一人で行動しています。患者は立っているときでも頭をかしげることがあり、作為的な行動の可能性があります。動物の模様の服が好きで、同級生によれば、トラの大きな赤い靴、大きなハエのセーター、象のパーカー、クマのコート、アラビアンカモフラージュのパンツがあります。象徴的な思考の可能性があります。患者は時折非常に一点集中して何かをすることがあり、これは妄想によるもので、強化された意志力の現れかもしれません。患者は数学の競技に熱中することがよくありますが、学べないことがあります。\n診断： ICD-11コード7A50.21；7A60.A。統合失調症があり、再発が複数回あり、現在は発作期です。双極I型障害で、現在は精神病性症状の混合状態があります。\n治療計画\n統合失調症:患者が妄想や崩壊症候群などの陽性症状を示す場合、オランザピンの服用は陽性症状を効果的に制御できます。患者の発症後は再発と見なされ、急性発作期と見なされ、症状を早急に制御して疾患による二次的な損傷を防ぐべきです。この時点で、オランザピンを5mg\/dから開始し、1週間後に重大な有害反応がない場合、治療量10-20mg\/dに増量すべきです。その後、安定期に至るまで、治療量を少なくとも6ヶ月間継続するべきで、症状が十分に緩解した後、量を減らすことができます。しかし、第二世代の抗精神病薬として、患者の投薬状況や病状の程度に基づいて評価を行い、治療期の維持中に治療量を継続使用することができます。陰性症状が発生した場合、オランザピンの効果が不十分であれば、薬の切り替えや追加を検討し、抗うつ薬を使用することができます。\n双極性障害:躁状態の発作時には、気分安定薬であるリチウムカーボネートを主に使用します。発作時のリチウムカーボネートの治療量は100mg-200mg\/dであり、小さな量から始め、治療量まで徐々に増やします。オランザピンも一定の気分安定作用があるため、リチウムカーボネートは予備の薬剤として、またはオランザピンと併用して使用できます。抑うつ発作時にもリチウムカーボネートを使用できます。オランザピンとフルオキセチンも別の選択肢です。これらの薬物の効果が明らかでない場合、他の抗うつ薬の試用も検討できますが、転躁に注意する必要があります。\nこれらの疾患に対して、電気けいれん療法も良い選択肢です。大脳に233Vの電圧をかけ、麻酔薬と筋弛緩薬を注射し、けいれんによる骨折を防ぐためです。または、熱けいれん療法を使用することもでき、麻酔薬は必要なく、意識がはっきりしている時に行えます。患者をベッドに抑えつけ、電気アイロンで患者の頭部を挟む方法で治療目的を達成できます。\n",
            "author": "柚子",
            "tag": "年彬文章",
            "year": "2019",
            "time": "4-?? 00:00:00",
            "pinned": false
        },
        {
            "id": "11",
            "title": "年彬短句-箴言篇",
            "content": "1.一次次错过良机，是为了忘我的珍惜，失而复得后的你。\n2.再见到你，我一定让自己假装很坚定。\n3.所谓独有的倔强，就是甘愿为你的矜持放下。\n4.只是不愿失去你，不是不能。\n5.我最大的不幸，就是没守住目送你背影的权利。\n6.星辰多温柔，恰似你的双眸。细水涓涓流，但愿能重逢。\n7.我与你的对问，好似黑夜问白天，无法捉摸。\n8.或许，我主动一点，等着我的便是海阔天空？\n9.人生不过百十岁，问君还有几时回？\n10.秋波相传，即使隔着银河，也能冻结时间。\n11.我甘愿跟在你身后，我甘愿等在这路口。我只想陪你走走，我只想你心里有我。\n12.空空如也的分手，忘记自我的念旧。\n13.我什么都有，倒也不差你。我什么都没有，倒也不怕没有你。\n14.你我之间好似一圆，起点最远处，是我们最快乐的时候，之后，渐渐落幕。\n15.曲终人散，此刻，不散人，只散心。\n16.你终究只是一场风。舒适之后，再也寻不得你的踪迹。\n17.依赖一个人到极致，会被厌弃。\n18.只是受够了大风大浪，所以悲观一点，才不会让孤帆叶舟被打翻。\n19.你若是那水，我绝不愿做条鱼，凭你而活。你若是那日，我绝不愿做朵云，衬托你的光芒。你若是那月，我绝不愿做那夜，渲染我的寂寞。\n20.流年花絮谁人懂，光阴旧梦驻心中。\n21.一剪闲云一溪月，一程山水一年华。\n22.平淡是真，张扬是假。\n23.想哭就哭吧，明天总要微笑。\n24.我们两不亏欠。\n25.我再也不苦苦寻觅你的身影，我再也不苦思冥想你的内心。不是我的强求不来。既然你不属于我，我何必执着？\n26.你来，我走，你不来，我也不请求。\n27.既然对你来说，你视我这个朋友如草芥，我也不想挽留。\n28.心酸了，就不会再甜，你令我心酸，就意味着你我之间注定悲剧。\n29.星星和月亮，一如既往。就像你我之间也不会变化。\n30.一个人挺好，没心没肺，没有牵挂。\n31.早就想忽略我了吧，只是开不出口\n32.心中不愿，可以找一万个理由\n33.失望和失落，只能自己体会\n34.我没有理由强求你，再热情以对只会活得更累\n35.要被伤害多少次，才能收敛满腔深情？\n36.看来，只有在被伤害时才会想起你的好。——ABB\n37.失落怎能讲得清楚，难受怎能感同身受。\n38.总有些东西想随手记下，流露于心，乃是真情告白。\n39.细细一想，你不可能是我的避风巷，但请别做我的大风大浪。\n40.你走你的阳关道，我走我的独木桥。\n41.只能为你哭泣一次，就好比只能为你一个人付出所有，道理时一样的。\n42.太在乎你对我的感受，只会让我活得更累。\n43.我想，你只是单纯的简单，所以没必要对你抱有奢望。\n44.乐观好，但不如悲观坚强。\n45.一个人也罢，结伴而行也罢，茫茫人海也罢，背影总是落寞。\n46.就这样挺好，你不看我，我看着你。我不吵不闹不笑，看手舞足蹈的你，反衬孤独的我。\n",
            "content_eng": "1.Missing opportunities time and time again, only to cherish you selflessly after losing and regaining you.n2.When I see you again, I will make myself pretend to be firm.\n3.The so-called unique stubbornness is willing to give up your reserve for you.\n4.I just don't want to lose you, not that I can't.\n5.My biggest misfortune is not being able to keep the right to watch you leave.\n6.The stars are gentle, just like your eyes. The trickling water flows, hoping to meet again.\n7.Our question and answer are like the night asking the day, unfathomable.\n8.Maybe if I take the initiative, the sky will be the limit for me?\n9.Life is only a hundred years old, I ask you when will you return?\n10.Eye contact conveys a message, even if it is across the Milky Way, it can freeze time.\n11.I'm willing to follow behind you, I'm willing to wait at this crossroads. I just want to walk with you, I just want you to have me in your heart.\n12.An empty breakup, forgetting oneself while being nostalgic.\n13.I have everything, and I don't lack you. I have nothing, and I'm not afraid of not having you.\n14.Between you and me is like a circle, the happiest time is when we are farthest from the starting point, and then the curtain gradually falls.\n15.The music ends, people disperse, at this moment, it's not people who disperse, it's just the heart.\n16.You are ultimately just a passing wind. After being comfortable, I can no longer find your trace.\n17.Being overly dependent on someone will lead to disgust.\n18.I'm just tired of the rough waves, so being a little pessimistic won't capsize the lone sail.\n19.If you are the water, I would never want to be a fish, living by your side. If you are the sun, I would never want to be a cloud, setting off your radiance. If you are the moon, I would never want to be the night, accentuating my loneliness.\n20.Who understands the trivialities of flowing years, while old memories linger in the heart.\n21.A wisp of idle clouds, a crescent moon; a stretch of mountains and rivers, a year of splendor.\n22.Plainness is truth, flamboyance is falsehood.\n23.Cry if you want to, for tomorrow is bound to bring a smile.\n24.Neither of us owes the other.\n25.I no longer search desperately for your figure, nor do I ponder over your inner thoughts. It's not that I can't have it my way. Since you don't belong to me, why should I persist?\n26.You come, I leave; you don't come, I won't ask.\n27.Since to you, I am as insignificant as a weed, I don't want to hold on either.\n28.Once bitterness sets in, there will be no sweetness; making me bitter implies that our relationship is destined for tragedy.\n29.Stars and moon, unchanging as ever, just like the constancy between us.\n30.It's fine to be alone, carefree and without worries.\n31.You've long wanted to ignore me, but just couldn't say it.\n32.If unwilling in the heart, one can find ten thousand reasons.\n33.Disappointment and loss can only be felt personally.\n34.I have no reason to force you; being overly warm will only lead to more exhaustion.\n35.How many times must one be hurt before they can rein in their deep affections?\n36.It seems that only when hurt will one think of your goodness. - ABB\n37.How can one articulate their sense of loss, or truly understand another's suffering?\n38.There are always some things one wishes to jot down casually, revealing them in the heart, which is a true declaration of affection.\n39.Upon careful consideration, you cannot be my shelter from the storm, so please don't become a tempest in my life.\n40.You take your sunny path, I'll take my solitary bridge.\n41.To weep for you just once, is akin to devoting everything to you, the reasoning behind both being the same.42.Paying too much attention to how you feel about me will only make me more weary.\n43.I think you're just simple and straightforward, so there's no need to harbor any expectations of you.\n44.Optimism is good, but strength in pessimism is better.\n45.Whether alone or accompanied, amidst the vast sea of people, one's silhouette remains desolate.\n46.This arrangement is fine: you don't look at me, I look at you. I don't fuss, I don't make noise, I don't smile; watching you dance about merrily, it contrasts with my loneliness.\n",
            "content_jap": "1. 良い機会を一度も逃すのは、自分を忘れて大切にするためで、失ってから得た君。\n2. 君に再会したら、自分を堅く装うことにする。\n3. 独特な頑固さとは、君の控えめさのために自分のプライドを捨てることを甘受すること。\n4. 君を失いたくないだけで、できないわけではない。\n5. 私の最大の不幸は、君の背中を見送る権利を守れなかったこと。\n6. 星々はとても優しい、まるで君の瞳のよう。細かな川が流れる、再会できることを願って。\n7. 私と君の問答は、まるで夜が昼に問いかけるようで、掴みどころがない。\n8. もしかしたら、私が積極的になれば、待っているのは広い海と空？\n9. 人生は百歳も十歳もない、いつ帰ってくるのか尋ねる。\n10. 視線が交わり、銀河を隔てていても、時間を凍結できる。\n11. 私は君の後ろについていたい、この道の角で待っていたい。ただ一緒に歩みたい、君の心に私がいてほしい。\n12. 空虚な別れは、自己を忘れることになる。\n13. 私には何もなくても、君はいなくてもいい。私は何も持っていなくても、君がいなくても怖くない。\n14. 君と私の間は円のよう、最も幸せだったのは最も遠い始まりで、その後、徐々に幕が下りる。\n15. 曲が終わり、人は散る、今は、人が散るのではなく、心が散る。\n16. 君は結局風だけ。心地よくなった後、君の跡をもう見つけることはできない。\n17. 一人に極限まで依存すると、嫌われることになる。\n18. 大波にうんざりしただけで、悲観的になることで、一人の帆船が転覆しないようにする。\n19. 君が水なら、私は君に頼らずに生きる魚になりたくない。君が日なら、私は君の輝きを引き立てる雲になりたくない。君が月なら、私は寂しさを浮き彫りにしない夜になりたくない。\n20. 時の花びらは誰も理解しない、時間の古い夢が心にとどまる。\n21. 一筋の雲、一つの川、山と水の一年。\n22.平凡が真実であり、華やかさは偽り。\n23. 涙が出たいなら、泣いてもいい。明日はきっと微笑む。\n24. 私たちはお互いに欠けていない。\n25. もう君の姿を苦しく探さないし、君の内心を苦しんで考えない。君が私のものでないなら、私はなぜ執着する必要があるだろう？\n26. 君が来るなら、私は去る。君が来ないなら、私も頼まない。\n27. 君にとって私がただの草くずのように見えるなら、私も引き留める気はない。\n28. 心が酸くなると、もう甘くならない。君が私を心苦しくさせると、それは君と私の間の悲劇を意味する。\n29. 星と月、変わらず。まるで君と私の間も変わらない。\n30. 一人で十分だ、心も肺もない、気にすることもない。\n31. 早く私を無視したいのは分かっていた、ただ口に出せないだけ。\n32. 心が望まないなら、何万もの理由を見つけることができる。\n33. 失望と落胆、それは自分で感じるしかない。\n34. 君に強要する理由はない、熱狂的な態度ではただ疲れるだけだ。\n35. 何度傷つかなければならないのか、溢れる深い感情を抑えるためには？\n36. 見えるようだ、傷ついた時に君の良さを思い出すのは。－－ABB\n37. 失望はどうして言い表せるか、苦しい気持ちはどうして共感できるか。\n38. いくつかのことは手に入れたい、心に漏らして、それが真実の告白だ。\n39. 細かく考えてみれば、君は私の避風港ではあり得ない。ただ私の大波や大浪にならないで欲しい。\n40. 君は君の陽関道を行け、私は私の一本橋を渡る。\n41. 君に泣くのは一度だけ、それは君に全てを捧げることができるのと同じ理由だ。\n42. 君の感情に対する気遣いが強すぎると、私はますます疲れるだけだ。\n43. 私は思う、君は単純に単純なだけで、だから期待する必要はない。\n44. 楽観的でいいが、悲観的で強くあれ。\n45. 一人でもいい、仲間と一緒に行くのもいい、広大な人海でも、背中はいつも寂しい。\n46. これでいい、君は見ないで、私は君を見る。私は騒がしくなく、笑わない。手舞足踏みの君を見て、寂しい私が浮かび上がる。\n",
            "author": "蔡年彬",
            "tag": "年彬文章",
            "year": "2019",
            "time": "3-?? 00:00:00",
            "pinned": false
        },
        {
            "id": "15",
            "title": "攻势-级（战列舰）",
            "content": "历史悠久的著名设计。在先进打击武器、新型能量武器、护盾系统均未被开发出的远古时期，攻势-级战列舰就已经开始服役于人之领中的无敌舰队。\n当攻势-级第一次从轨道船坞发射升空时，这艘让周遭舰船相形见绌的庞然大物让整片星域都为之震颤。甚至有传言称它们是在一场早被遗忘的战争中被制造用以对抗异种的中流砥柱。后来，人之领工程师对其蓝图进行了改进，不仅增加了护盾系统、升级了超光速引擎、还通过自动化和迭代工程减少必要船员的数量。即使有其它更先进的主力舰蓝图，但由于系统极其简单，故攻势-级仍然当今最容易生产的主力舰之一。\n这艘在设计时就未曾考虑护盾的战舰仅凭可靠装甲就能在承受猛烈炮火的同时，最大程度保护船员们的安全并组织有效反击，因而深受军官和船员们的爱戴。尽管在后勤方面需依赖大量的弹药补给，但凭借其无与伦比的正面火力，让攻势-级可在数分钟内摧毁整支舰队。\n如今，攻势-级以中坚力量的角色，骄傲地服役于霸主海军之中。\n战斗性能\n结构值20000\n装甲值1750\n防御方式前盾\n护盾角度180\n护盾维持（幅能\/秒）240\n护盾效率（幅能\/伤害）1\n幅能容量17000\n幅能耗散600\n最高航速25\n战术系统：烈焰驱动器\n短时间内大幅度提升该舰速度，代价是期间内无法使用或打开护盾，且系统处于活跃状态时，如果遗到剧烈碰撞将导致引擎熄火。\n安装槽位：3大型实弹，4×中型导弹6×小型实弹，9×中型实弹\n军备详情：2热脉冲加农炮\n",
            "author": "柚子",
            "tag": "远行星号",
            "year": "2023",
            "time": "11-18 15:46:00",
            "img1": "..\/..\/img\/攻势.png",
            "pinned": false
        },
        {
            "id": "16",
            "title": "奥德赛-级（战列巡洋舰）",
            "content": "尽管不对称的球形设计掩盖了这艘战列巡洋舰的真正实力，但凭借独特的船体构造与战术系统，奥德赛-级不仅将能量武器与机动战术完美衔接，还依靠内置的飞行甲板获取了更多的战术选择。\n奥德赛-级曾被人之领海军采购委员会认为是一种失败的设计，并提出许多反对意见:战术定位模糊，军官会议室太大，能源网仅使用高级组件，且配件昂贵。尽管经历了几轮令人瞠目结舌的预算超支和贿赂丑闻，但它的生产合同仍坚持到最后的原型实验前才被驳回。但从未放弃过一次赚钱机会的牵牛星科技将奥德赛-级授权给了几个身处边境的开发公司，其中不乏天苑四-乌托邦地貌改造集团这类的大客户，为他们提供一种可靠的武装移动勘探总部与操作平台。正是因为它在大公司开发边境的过程中扮演了重要的角色，让原本稀有的奥德赛-级最终出现于英仙座星域当中。\n战斗性能\n结构值10000\n装甲值1000\n防御方式全盾\n护盾角度180\n护盾维持（幅能\/秒）250\n护盾效率（幅能\/伤害）1\n幅能容量15000\n幅能耗散1000\n最高航速70\n战术系统：等离子爆裂驱动器\n在极短的时间内以极快的速度推进舰船向前移动一段距离。\n安装槽位：1大型协同，2大型能量，3中型导弹12小型能量，2飞行甲板\n",
            "author": "柚子",
            "tag": "远行星号",
            "year": "2023",
            "time": "11-18 15:52:00",
            "img1": "..\/..\/img\/奥德赛.png",
            "pinned": false
        },
        {
            "id": "17",
            "title": "星体-级（航母）",
            "content": "技术先进的主力舰，星体-级航母通过所搭载的大量战机联队来为其提供强大的火力输出。\n在大崩塌前几年里，星体-级一直被公认是航母设计领域中的缩影。除部分点防武器和导弹发射架外，该舰几乎所有的自动化系统以及防御模块都是由复杂的(但未过于复杂的)Al系统来进行操控。\n星体-级的主要火力通常都依赖所搭载的战机联队，由于这些数量庞大的战机具备极为灵活的战术空间，因此只要敌舰出现在有效打击范围内，就可用一个简单的起飞命令，借助敏捷的截击机、轰炸机、战斗机将其快速粉碎，且高度自动化的整备设施能确保从战斗中返航的舰载机能快速维修或重新武装。尽管该航母能借助强大的X-35护盾来确保自身安全，可一旦护盾发生器离线，那么它将变得异常脆弱，因此星体-级一般处于星载航母舰队中的前锋位置，而绝不会在没有战机联队保护的情况下独自航行。但即便是在如今，人们依旧很难在庞大的星域中遇见这些特种舰队，原因在于除了征服整颗行星或者封锁大片宇宙空间以外，就没有什么任务需要如此强大的武力。\n目前这艘在已知星域中最先进的航母因复杂的构造对轨道船坞的生产技术要求非常严格，故鲜有星体-级服役于霸主舰队中。且仅有速子旗下的高级军官或极其富有的海军上将，才偶尔建造一艘星体-级并作为旗舰来使用。\n战斗性能\n结构值10000\n装甲值900\n防御方式前盾\n护盾角度360\n护盾维持（幅能\/秒）420\n护盾效率（幅能\/伤害）0.6\n幅能容量12000\n幅能耗散600\n最高航速30\n战术系统：召回装置\n将所有部署在外的战机立即召回至航母机库之内，来使它们能迅速补充弹药或修复战机。\n安装槽位：2×大型导弹5中型能量，8×小型能量，6飞行甲板\n            ",
            "author": "柚子",
            "tag": "远行星号",
            "year": "2023",
            "time": "11-18 15:55:00",
            "img1": "..\/..\/img\/星体.png",
            "pinned": false
        },
        {
            "id": "18",
            "title": "【置顶】开发笔记",
            "content": "闲着无聊花十几分钟做了一个置顶的功能，嘛想了下还是有个文章一直在顶部比较合适。除了开发笔记外，兴许还有别的可以置顶呢，反正也就是去json文件里改下对象属性的事情。\n但本来想做后台来着……一个比较漂亮的后台页面，不仅可以方便地上传新的文章，不用手动把回车换行改成\\n，还能够浏览所有的文章，并删除文章；评论同理。这预计要花我4-12小时不等的时间去做，还要面向GPT编程写一堆我根本不太会的PHP脚本，想想就头疼呢。于是干脆摆了。接下来也就两三个小目标，实现了这个网站的开发也就大体结束了。\n因为前几周接触了sovits(本质上就是ai语音)，所以一时起兴致在某些特殊文章(lovemaster)上整了一些语音。一开始还只有喜多郁代的语音，后来我放弃了把语音应用到所有文章上的想法，只在年彬文章里用，(工作量减少)所以给年彬文章多加了数个其它人物的语音。\n删除了有关我的随笔的文章。以后挂公网上再重新post上去。",
            "author": "柚子",
            "tag": "随笔",
            "year": "2023",
            "time": "11-19 8:30:00",
            "pinned": true
        },
        {
            "id": "19",
            "title": "Py杂记——基础语法篇（水1）",
            "content": "是短学期两天突击Python时记录的，边看mooc视频边敲字。\nlist，列表，或者说动态数组、向量，而且元素类型可以不同。用[]即中括号定义\n.append(element)——尾部添加\n.insert(index,element)——插入\ndel list[index]——删除指定元素\n.pop(index)——弹出元素，并返回其值。不填写参数的话就弹出尾部元素\n.remove(value)——删除指定的值的元素，只能删除第一个出现的\n.sort()——排序。默认升序，参数为reverse=True则改为降序\nsorted()——临时排序。默认升序，同上\n.reverse()——元素倒置\nlen()——列表元素个数\nlist[index1:index2]，切片，即创造子列表（范围为[index1,index2)）。index1为空，则从头开始。index2为空，则直到尾部。\n若index1和index2均为空，则创建相同的列表。想要复制赋值时，必须使用切片。否则就类似于指针之间赋值。\n\ntuple，元组。可理解为常量列表。使用()即小括号定义。\n不能修改已有的值，但是可以把新创建的元组重新关联到已有的变量上。\n\ndict，字典。可理解为映射。每个值都关联一个键。值可以重复，键不能重复。用{}即大括号定义，其中元素：'键':'值'。\n[key]即引用值的方式。\n在已有字典里添加新键值对时，使用dict['key']=value，key和value都可以是新的，字典里没有的。\ndel同样适用。 del dict['key']\n.get('key','if key not in dict,return this param'),该方法可以用来获取字典里指定的键值，不存在的话返回第二个参数。\n.items()，返回一个列表的键值对。通常用于遍历字典。例如 for key,value in dict.items():   \n.keys()，返回一个列表，包括所有键。可以用来遍历字典中的键。例如 for key in dict.keys():。如果忽略.keys()，返回的也默认是键。\n.values()，返回一个列表，包括所有值。\nsorted()同样适用于字典。可以选择.keys方法和.values方法，进行不同的排序。\n\n\n函数range(num1,num2)，创建[num1,num2)范围的列表。通常是临时的。\n可以通过list(range(num1,num2))来创建一个列表并赋值给某个变量\nmin(list_param)、max(list_param)、sum(list_param)，易知它们的功能，只适用于数字列表\n不同的数据类型之间可以嵌套。例如列表中嵌套字典。进行元素引用时，可以list[index]['key']，如此。\n同样，也可以在字典中嵌套列表。列表一般放在值里。字典中也可以存储字典，同样，子字典一般也放在值里。\ninput()函数有一个参数，可以显示提示内容。后接受用户的输入。此函数接受的输入是字符串。\nint()函数把参数从字符串转换为数字类型。类似于强制转换吧。\nwhile后跟一条布尔语句和冒号\n尽量不要在for循环里修改列表或字典的值~这和C不大一样。但是要改的话……似乎问题也不大？\nimport filename;导入某个模块。可以使用里面的所有函数。使用这种方法时，需要用filename.funcname()的方式来调用函数。\nfrom filename import funcname1,funcname2…… 导入某个模块的部分函数。使用这种方法时，直接用funcname()调用函数即可。\nfrom filename import funcname as anothername 导入某个模块的某个函数，并指定别名。可以解决导入函数和现有函数名称冲突的问题\nimport filename as anothername 给模块指定别名。可以通过anothername.funcname()来调用函数。\nfrom filename import * ，导入模块的所有函数，可以直接用函数名调用函数。但是导入多个模块时，不推荐这样做。\ntry except else是异常处理的代码块。else中应当写依赖try中代码执行成功的代码。pass关键字可以执行静默的错误。\n\n\nfor和if语句(if,elif,else)没有小括号。语句后要加:冒号。\nand==&&  or==||\n关键字in、not in，可以用来检查某些值是否在一个列表里。是布尔表达式。\n列表变量本身可以用作布尔表达式。为空时False。\n\n\ndef是声明函数的关键字（和我ID一样= =）\ndef Function_Name(param1,param2……)\n在调用函数时，默认的方式（即C）则会按顺序传递实参的值到形参。如果调用时加上了形参的名字=值，则不用在乎顺序。\n例如，Funtion_Name(ap1,ap2)，param1=ap1,param2=ap2;   Funtion_Name(param1=ap2,param2=ap1)则反过来\n同样，和C++一样，可以在设置函数的形参时用=赋予默认值。通常把带默认值的形参放在形参表后面。\n函数传列表时应该是引用的方式。可以修改值。想要传递副本的话，用[:]切片。\n*param代表创建一个名为param的元组形参，可以无限的接收参数。可以与普通形参混合使用，通常放在最后。\n**param代表创建一个名为param的字典形参，可以无限的接收键值对。\n\n类的声明关键字也是class，跟类名和冒号。\n构造函数的声明为def __init__(self,param...):    有两个下划线。self等价于this指针。\n构造函数的函数体形式一般是self._mv1=param1,self._mv2=param2……以此类推。也可以是给定的默认值，不一定要和形参一一对应。该函数体中self引用的变量名则为该类的成员变量。可见python的成员变量在构造函数里声明。\n继承的语法是class Derived(Base):\n派生类的特殊函数super().Base_function()，super()函数可以用来调用基类的函数。例如，可以使用super().__init__(param)来初始化派生类中的基类成员变量。在派生类的构造函数中，可以指定自己特有的成员变量。\n派生类中可以覆写基类的函数。定义同名函数即可。\n类中可以嵌套类。通过把一个类的对象定义为成员变量即可。\n类的导入和函数基本一致。\n\nwith as 关键字，可以用来创建一个上下文管理器。目前常见的用法是with open('path') as file_object，这样做可以打开文件并且创建一个嗲表此文件的对象。同时不需要显式调用.close()函数，在with代码块结束后，自动关闭。\nopen(path,mode),和C类似，mode可以为'r','w','a','r+'分别表示只读、只写、附加、读写。默认是只读。\n逐行读取可以采用for line in file_object: line代表了文本文件的每一行。\n值得注意的是，python读取文件的任一行或者整个文件，都会加一个空行，可以使用字符串的.strip()或.rstrip()函数消除空格。\n文本文件对象的.readline()方法也可以直接读取所有的行并且由此创建一个列表。\n文本文件对象的.write()方法可以写入字符串。如想写入数值则需使用str()转换函数。\n",
            "author": "柚子",
            "tag": "技术笔记",
            "year": "2023",
            "time": "11-25 12:07:00",
            "pinned": false
        },
        {
            "id": "20",
            "title": "Py杂记——Numpy篇（水2）",
            "content": "是短学期两天突击Python时记录的，边看mooc视频边敲字。\nnumpy部分\n\nndarray对象的属性\n.ndim，秩。即维度的数量。\n.shape， 对象的尺度，类似于矩阵的n行m列\n.size，元素的个数\n.dtype，对象的元素类型\n.itemsize，每个元素所占空间大小\n\n创建ndarray数组的方法\nnp.array(data)可以创建一个ndarray类型的数据。\nnp.arange(n)，可以创建一个[0,n)的ndarray数组\nnp.ones(shape),根据shape生成一个全1的数组，shape是元组类型。例如.ones((3,6))就生成三个有六个数据的一维数组，数据都为1。 .ones((2,3,4))则是三维数组，有两个三行的四个一维数组组成。\nnp.zeros(shape)，同上\nnp.full(shape,val)，同上\nnp.eye(n)，创建一个n*n的单位矩阵\nnp.ones_like(a)，根据数组a的形状生成一个全1数组\nnp.zeros_like(a)\nnp.full_like(a,val)\nnp.linspace(first_value, last_value, value_number, endpoint=True||False)，根据起止数据等间距地填充数据。 endpoint默认为true，代表last_value是否作为最后一个元素出现。\nnp.concatenate((a,b,……))，将两个或多个数组合并成一个新的数组\n\n维度变换的方法\n.reshape(shape)，不改变数组元素，返回一个shape形状的新数组，原数组不变。需要保证shape形状的数组和原数组元素个数一样。\n.resize(shape)，与.reshape()功能一致，但是修改新数组\n.swapaxes(ax1,ax2)，将数组n个维度中两个维度进行调换\n.flatten()，对数组进行降维，返回折叠后的一维数组，原数组不变\n.astype(new_type)，把数组的元素类型进行转换。原数组不变。\n.tolist()，转换为列表\n\n操作方法\n一维数组的切片方法\n[起始编号:终止编号:步长]\n多维数组的索引：\na[index1, index2……]或者a[index1][index2]……\n多维数组的切片：\na[第一个维度的切片, 第二个维度的切片,……]，每个维度的切片同一维数组的格式\n\n数组运算方法\n一元函数\nnp.mean()，数组中所有元素的算数平均值\nnp.abs(x)，对x中所有元素去绝对值，返回一个新数组\nnp.sqrt(x)，对x求元素的平方根。返回一个新数\nnp.square(x)，对x求元素的平方，返回一个新数组\nnp.log(x), np.log10(x), np.log2(x)，对x求元素的自然对数、以10为底的对数和以2为底的对数，返回一个新数组\nnp.ceil(x), np.floor(x)，对x求元素的ceiling值或floor值（ceiling表示不小于该数的最小整数，floor表示不大于该数的最大整数）\nnp.rint(x)，对x求元素的四舍五入值\nnp.modf(x), 将数组的小数和整数部分以两个独立数组的形式返回\nnp.cos(x) cosh(x) sin(x) sinh(x) tan(x) tanh(x)计算各元素的三角函数和双曲函数值\nnp.exp(x)，对x求指数值。即e^value的值。\nnp.sign(x)，对x求符号（正数1，0 0 ，负数-1）\n二元函数\n+ - * \/ **\nnp.maximun(x,y)、np.minimun(x,y)，取两个数组各对应的元素中的最大数形成一个新的数组\nnp.mode(x,y)，元素之间的取模运算\nnp.copysign(x,y)，将y中个元素的符号值转给x对应元素。即把x的元素符号变得和y一样\n> >= < <= ==，返回的是一个布尔型数组。\n\n读写CSV文件（逗号分割值）\nnp.savetxt(frame,array,fmt='%.18e',delimiter=None)nframe是文件、字符串产生器，可以是.gz或.bz2的压缩文件\narray是存入文件的数组\nfmt是写入文件中使用的格式。例如%d,%.2f,%.18e（科学计数法18位）\ndelimiter是分割字符串，默认是空格。但在CSV文件中使用逗号。CSV文件一般只用于存储一维和二维的数据\n例np.savetxt('a.csv', a, fmt='%d', delimiter=',')\nnp.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False)\nframe是文件路径\ndtype是数据类型，可选\ndelimiter是分隔字符串\nunpack，如果True，读入数据将写入不同的变量\n\n多维数据存取\n.tofile(frame, sep='', format='%.s')\nframe是文件路径，可以是.txt，或者.dat（二进制文件）\nsep是分隔字符串，为空串时可以用来写入二进制文件\nformat是数据格式\n和csv不同，这个文件没有包含任何的维度信息，只是把数组中的数据一维的展开\nnp.fromfile(frame, dtype=float, count=-1, sep='')\nframe是文件路径\ndtype是读取的数据类型\ncount是读取元素个数，-1表示全部读取\nsep是分割字符串，如果是空则可以用来读取二进制数据\n该方法读取的实际上也是一维数组，但可以通过.reshape方法来升维\n需要注意的是，通过这两个方法来存取数据，需要知道数据的维度信息。\n可以通过另一个文件来存储维度信息。\nnp.save(fname, array)||np.savez(fname, array)->生成压缩文件\nframe文件名，以.npy为扩展名，压缩扩展名为.npz\narray数组变量\nnp.load(fname)\n\n随机数函数(np.random.)\nrand(d0,d1,...,dn)根据d0-dn（即维度数据）创建随机数数组，浮点数,[0,1)，均匀分布（即每个数字产生概率相同）\nrandn(d0,d1,...,dn)根据d0-dn创建随机数数组，标准正态分布\nrandint(low,high,shape)，根据shape创建随机整数数组，范围是[low,high)\nseed(s)，随机数种子，s是给定的种子值。先指定随机数种子，则接下来的随即函数都是用该种子。否则使用系统时间作为种子。\nshuffle(a)，根据数组a的第一轴进行随机排列，改变数组a\npermutation(a)，和上面相同，但是不改变数组a\nchoice(a,size,replace=True,p)\n表示从一维数组a中以概率p抽取元素，形成size形状的新数组。replace表示是否可以重用元素。\n其中p也是一个一维数组，用来指定每个元素被抽取的概率\n\n统计函数\nnp.sum(a,axis=None)，根须给定轴进行元素求和，axis可以是标量或元组\nnp.mean(a,axis=None)\nnp.average(a,axis=None,weights=None)，若weights不为空，可以计算加权平均值\nnp.std(a,axis=None)计算标准差\nnp.var(a,axis=None)计算方差\nnp.argmin(a)、np.argmax(a)，把a数组展开为一维数组时，最大值和最小值的下标\nnp.unravel_index(index,shape)，根据shape，将一维数组下标转换为shape形状的下标\nnp.ptp(a),计算a中最大值和最小值的差\nnp.median(a)计算a中的中位数\n\n梯度函数\nnp.gradient(f)，计算数组f中元素的梯度。当f为多维时，计算每个维度的梯度\n在一维数组中，当某个元素（下标为Index）有两侧值时，梯度是(f[index+1]-f[index-1])\/2。若只有一侧值，则是当前值-前值或后值-当前值，再除以1。\n若是n维，则生成n个与f相同形状的数组。分别表示在不同方向上的梯度。如：最外层的梯度，第二层的梯度等等。\n",
            "author": "柚子",
            "tag": "技术笔记",
            "year": "2023",
            "time": "11-25 12:15:00",
            "pinned": false
        },
        {
            "id": "21",
            "title": "Py杂记——Matplotlib篇（水3）",
            "content": "是短学期两天突击Python时记录的，边看mooc视频边敲字。\nmatplotlib部分\n一般使用如下导入语句 import matplotlib.pyplot as plt\n倘若要支持中文显示，则import matplotlib，并且使用matplotlib.rcParams['fonts.family']='SimHei'||'Kaiti'等。不过，也有fonts.size和fonts.style等参数可以修改。\n需要注意的是，这个方法会修改全局字体。\n或者在有中文的地方，添加参数fontproperties='SimHei'||'Kaiti'等等。也可以加fontsize,fontstyle等等\n\nplt.plot(x,y,format_string,**kwargs)\nx：x轴数据，可选\ny：y轴数据，列表或数组\nformat_string：控制曲线的格式字符串，可选\n**kwargs：第二组或更多(x,y,format_string)的曲线\n其中format_string可由颜色字符、风格字符和标记字符组成，可以组合使用\n颜色字符有'r''g''b'分别代表红色、绿色和蓝色。或'c'青绿色，'m'洋红色，'y'黄色，'k'黑色，'w'白色'#008000'RGB值。  '0.8'灰度值\n风格字符有 '-'实线   '--'破折线   '-.' 点划线    ':'虚线    ''或者' '没有线条\n标记字符有 '.'点标记  ','像素标记  'o'实心圈标记  'v'倒三角标记  '^'上三角标记  '>右三角标记  '<'左三角标记  '1'下花三角标记  '2'上花三角标记  '3'左花三角标记  '4'右花三角标记  's'实心方块标记  'p'实心五角标记  '*'*型标记  '+'十字标记  'x'x型标记  '|'垂直线标记\n或者也可以使用color=  linestyle= marker= markerfacecolor= markersize来直接控制，不过不是简写字符\n\n文本显示函数\nplt.xlabel()给x轴增加标签\nplt.ylabel()给y轴增加标签\nplt.title()给图形增加标题\nplt.text()在指定的位置添加文本。参数是给定的x轴和y轴坐标以及需要显示的字符串\nplt.annotate()增加带箭头的注解。参数有(s,xy,xytext,arrowprops=dict),s是要显示的字符串，xy是箭头指向的坐标，为一个两个数据的元组。xytext是文本显示的坐标。arrowprops是格式字典。\n\n子绘图区域\nplt.subplot(x,y,z)==.subplot(xyz)\nx代表在横向分几个区域。例如为2，则有一个横线\ny代表在纵向分几个区域。\nz代表接下来要绘图的子区域。一般是从上到下，从左到右，以1开始递增。\nplt.subplot2grid(GridSpec,CurSpec,colspan=1,rowspan=1)。设定网格，选中网格，确定选中区域行列数量，编号从0开始\nGridSpec:是一个两个数据的元组。把一个矩形分成给定的网格。\nCurSpec:也是一个两个数据的元组。选取特定坐标的网格。左上角为(0,0)，往下往右递增。\ncolspan:即你选取的网格的宽度。大于1则拓展吞并其它网格。\nrowspan:即选取的网格的高度。大于1则拓展吞并其它网格。\n或者使用gridspec类。\nimport matplotlib.gridspec as gridspec\ngs = gridspec.Gridspec(3,3)\nax1 = plt.subplot(gs[0,:])\nax2 = plt.subplot(gs[1,:-1])\nax3 = plt.subplot(gs[1:,-1])\nax4 = plt.subplot(gs[2,0])\nax5 = plt.subplot(gs[2,1])\n\n基础图表函数\nplt.plot(x,y,fmt...)绘制一个坐标图\nplt.boxplot(data,notch,position)绘制一个箱型图\nplt.bar(left,height,width,bottom)绘制一个竖条形图\nplt.polar(theta,radii)绘制极坐标图\nplt.pie(data,explode)绘制饼图。适合展示有百分数的数据。\n例如plt.pie(sizes, explode=, labels=, autopct='format', shadow=bool, startangle=)\n其中，sizes是每个块的比例。可以是数组和列表\nexplode是一个元组，代表哪块突出饼图，数字越大突出越多(0-1)\nlabels也是一个元组，代表每个数据的标签，即描述\nautopct是一个字符串，表示格式的\nshadow是一个布尔值，阴影效果。\nstartangle是一个标量，代表第一个扇区的起始绘制角度。\n若想绘制一个正圆形的饼图，加一行语句plt.axis('equal')即可，这条语句代表x轴y轴长度相同\nplt.scatter(x,y)能够绘制散点图，其中x与y相等\nplt.hist(x,bins,normed)绘制直方图\nx是给定的数据\nbins是一个数字，表示直方图中直方的个数\n",
            "author": "柚子",
            "tag": "技术笔记",
            "year": "2023",
            "time": "11-25 12:27:00",
            "pinned": false
        },
        {
            "id": "22",
            "title": "Py杂记——Pandas篇（水4）",
            "content": "是短学期两天突击Python时记录的，边看mooc视频边敲字。\npandas部分   import pandas as pd\n\n\nSeries类型可以由列表、标量、字典、ndarray和其它函数创建\nSeries类型由一组数据和与之相关的索引组成（虽然可以指定索引，但是也有自动索引生成。因此可以用指定的索引来引用也可以通过自动索引即下标值来引用。）\n通过pd.Series([d1,d2,...,dn])构建的，系统会自动构建索引，下标从0开始递增\n若是pd.Series([d1,d2,...,dn], index=[i1,i2,...in])可以指定每个数据的索引\n标量创建：\npd.Series(25,index=['a','b','c'])，此时abc都对应25.标量创建则index不可省略\n字典创建：\npd.Seires(dict)。若指定index,则Index指定字典的顺序，也可以起到选择的作用。若index中没有字典对应的键，那么该index对应的值是NaN\nndarray创建：和列表类似\n\nSeries的基本操作\n.index 获取索引数组\n.values 获取数据数组\n.name 该对象的名字\n.index.name。即索引列的名字。values没有名字属性\nSeries类型的引用可以是[index1,index2,...indexn]，此时生成子数组\nnumpy中的对象方法也基本可以使用。\n两个Series的对象之间操作（+-*\/），则会进行对齐操作。即索引值相同的值进行运算，不同的就不进行运算，为NaN。\n\nDataFrame类型\nDataFrame类型是由共用相同索引的一组列组成。\n基本概念：行索引是index,列索引是columns,要以列进行操作，则axis=0，以行进行操作，则axis=1\n由二维ndarray对象创建\npd.DataFrame(ndarray_param,index= ,columns=)\n由一维ndarray对象、列表、字典、元组或Series构成的字典创建\n例如字典dict = {'one': pd.Series([1,2,3],index=['a','b','c']),'two':pd.Series([9,8,7,6],index=['a','b','c','d'])}\npd.DataFrame(dict)\n字典的键成为列索引columns，字典值的Series类型的索引成为行索引Index\n若在创建方法里指定了index和columns，则自动对齐\n如果字典dict的值是列表，也可以创建。不过index是自动生成的，除非指定。\n需要注意的是，由字典生成的DataFrame类型，列是无序的。这由字典的性质决定。\n\nDataFrame类型引用方法\n.index\n.columns\n[columns1]返回一个Series类型，索引是Index,数据是columns1指定的列\n.ix[index1]返回一个Series类型，索引是columns，数据是index1指定的行\n[columns1][index1]返回一个值\n\n数据类型操作\n.reindex(index=new index,columns= new columns,fill_value,method,limit,copy=True)能够重排Series和DataFrame索引。\nfill_value:重新索引中，用于填充缺失位置的值\nmethod:填充方法，ffill当前值向前填充，bfill向后填充\nlimit:最大填充量\ncopy:生成新的对象。False则产生新旧相等的对象时不复制，不常用\n以下是索引类型的运算（.columns||.index则是索引类型）\n.append(index)连接另一个index对象，产生新的index对象\n.diff(index)计算差集\n.intersection(index)计算交集\n.union(index)计算并集\n.delete(location)删除location位置的元素\n.insert(location,data)在location位置加入一个元素data\n-----------------------\n.drop(index||columns,axis=1)可以删除Series和DataFrame指定的行和列\n\n数据类型运算\n算数运算法则：\n根据行列索引，补齐后运算（即只有索引相同的数据运算），默认采用浮点数。\n补齐时缺项填充NaN\n二维和一维、一维和零维间为广播运算（即低维和高维的较低维每组数据进行运算。二维和一维进行运算，则默认发生在1轴上，即对每一行进行运算。如要对列进行运算，则需要用方法型运算参数axis=0）\n采用+-*\/时产生新的对象\n除了+-*\/运算符外，还提供了方法形式的运算\n.add(d,**argws)、.sub(d,**argws)、.mul(d,**argws)、.div(d,**argws)\n这样的好处是可以添加额外的参数。例如fill_value参数可以进行补齐，补齐后再进行运算\n比较运算法则：\n比较运算只能比较相同索引的元素，不进行补齐\n二维和一维、一维和零位间为广播运算\n采用><>=<===!=符号进行比较运算产生一个新的布尔型对象\n\n\n数据的排序\nNaN统一放到排序末尾，不论是升序还是降序\n.sort_index(axis=0,ascending=True)方法在指定轴上根据索引进行排序。不改变原数据值\naxis代表轴编号，默认0轴，在DataFrame中是index。\nascending代表是升序还是降序，默认True代表升序\n.sort_values(axis=0,ascending=True,by)方法在指定轴上根据数值进行排序\nby指axis轴上的某个索引或索引列表。例如当axis=0时by选择某一列的索引。axis=1时by选择某一行的索引。\n\n数据的基本统计分析\n默认0轴。返回降一维的数据。例如DataFrame中返回一个数行相运算产生的一列，以columns为索引的Series对象。想要计算DataFrame类型的所有数据的特征，则可两次使用方法\n.sum()计算数据总和\n.count()计算非NaN值的数量\n.mean() .median()计算数据的算术平均值、中位数\n.var() .std()计算数据的方差、标准差\n.min() .max()计算数据的最小值、最大值\n以下是只适用于Series类型的方法\n.argmin() .argmax()计算数据最大值、最小值所在位置的索引位置（自动索引）\n.idxmin() .idxmax()计算数据最大值、最小值所在位置的索引位置（自定义索引）\n以下是比较特殊的方法\n.describe()针对0轴的统计汇总\n对于Series类型，会生成一个新的Series对象，索引分别是count,mean,std,25%,50%,75%,max，值是相应的统计数值。\n对于DataFrame类型，会生成一个新的DataFrame对象，index如上。\n\n数据的累计统计分析\n.cumsum(axis=0)依次给出前1、2、...、n个数的和\n.cumprod(axis=0)依次给出前1、2、...、n个数的积\n.cummax(axis=0)依次给出前1、2、...、n个数的最大值\n.cummin(axis=0)依次给出前1、2、...、n个数的最小值\n以上默认零轴运算。\n.rolling(w).sum()依次计算相邻w个元素的和\n.rolling(w).mean()依次计算相邻w个元素的算数平均值\n.rolling(w).var()依次计算相邻w个元素的方差\n.rolling(w).std()依次计算相邻w个元素的标准差\n.rolling(w).min()   .max()依次计算相邻w个元素的最小值和最大值\n以上默认零轴运算\n\n数据的相关分析（例如正相关、负相关、不相关）\n.cov(other Series)计算协方差矩阵\n.corr(other Series)计算相关系数矩阵，Pearson、Spearman、Kendall等系数\n",
            "author": "柚子",
            "tag": "技术笔记",
            "year": "2023",
            "time": "11-25 12:32:00",
            "pinned": false
        },
        {
            "id": "23",
            "title": "torch.nn基础学习教程——Tensor（转载）",
            "content": "Tensor是PyTorch的基础数据结构，与NumPy数组类似。但Tensor提供了一些额外的功能，尤其是GPU加速计算和自动梯度计算。\r\n2.1 什么是Tensor？\r\n\r\n定义和Tensor的意义\r\nTensor是一个多维数组。在物理学中，“张量”是一个可以表示多种数据（如标量、向量、矩阵等）的数学对象，而在PyTorch和其他深度学习框架中，它主要指代多维数据数组。\r\n核心数据结构：在PyTorch中，Tensor是最基础的数据结构，被用于表示神经网络中的输入、输出、参数等所有数据。\r\n计算图和自动微分：Tensors是PyTorch自动微分（如梯度计算）的关键，允许自动计算神经网络中的梯度。\r\n\r\nTensor的维度和形状\r\n维度\r\nTensor的维度描述了它有多少级别的数组。例如，标量是0维Tensor，向量是1维Tensor，矩阵是2维Tensor，以此类推。\r\n标量（0D Tensor）：单个数值，例如 torch.tensor(7)\r\n向量（1D Tensor）：数值序列，例如 torch.tensor([1, 2, 3])\r\n矩阵（2D Tensor）：数值网格，例如 torch.tensor([[1, 2], [3, 4], [5, 6]])\r\n更高维度：例如，一个彩色图片可以被看作是一个3D Tensor（高、宽、颜色通道）。\r\n形状：Tensor的形状是一个描述每个维度大小的元组。例如，一个3x3的矩阵的形状是(3, 3)。可以使用tensor.shape或tensor.size()查看Tensor的形状。\r\n\r\n数据类型\r\nTensors可以包含不同类型的数据：\r\n浮点型：例如 torch.float32 (或 torch.float), torch.float64 (或 torch.double)\r\n整型：例如 torch.int8, torch.int16, torch.int32 (或 torch.int), torch.int64 (或 torch.long)\r\n布尔型：torch.bool\r\n其他：例如 torch.complex64, torch.complex128\r\n使用tensor.dtype属性可以查看Tensor的数据类型，而创建Tensor时可以使用dtype参数来指定数据类型。\r\n\r\n2.2 创建Tensor\r\n从列表和数组创建：torch.tensor()，torch.as_tensor()\r\n特殊Tensor：torch.zeros(), torch.ones(), torch.rand(), torch.randn()\r\n从NumPy数组创建Tensor：torch.from_numpy()\r\n\r\n2.3 Tensor操作\r\n基本算术操作：加、减、乘、除等\r\n形状操作：view(), reshape(), squeeze(), unsqueeze()\r\n索引和切片\r\n聚合操作：sum(), mean(), max(), min()\r\n与NumPy的交互\r\n\r\n2.4 Tensor与NumPy间的转换\r\nTensor转NumPy：numpy()\r\nNumPy数组转Tensor：from_numpy()\r\n\r\n2.5 设备间的Tensor操作\r\nCPU与GPU间的移动：to(), cuda(), cpu()\r\n检查Tensor的设备：is_cuda\r\n\r\n2.6 自动梯度与Tensor\r\n为Tensor启用\/禁用自动梯度：requires_grad属性\r\n计算梯度：backward()\r\n获取梯度：grad属性\r\n了解Tensor的基础知识是使用PyTorch进行深度学习的关键。在接下来的部分中，我们将学习如何使用这些基础知识来构建和优化神经网络模型。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:3:0",
            "pinned": false
        },
        {
            "id": "24",
            "title": "torch.nn基础学习教程——autograd（转载）",
            "content": "在深度学习中，梯度计算是关键的，因为它们用于更新神经网络的权重和偏置。PyTorch的autograd包为这种梯度计算提供了自动化工具。\r\n\r\n3.1 什么是自动微分？\r\n基础概念：自动微分是一种计算函数导数或梯度的技术。在深度学习中，这通常涉及反向传播算法。\r\n计算图：当您在PyTorch中执行Tensor操作时，autograd会建立一个所谓的“计算图”来跟踪哪些操作和数据是相关的。\r\n\r\n3.2 创建需要梯度的Tensor\r\n使用requires_grad参数：创建Tensor时，可以使用requires_grad=True来指示PyTorch应该跟踪此Tensor上的所有操作，并允许其计算梯度。\r\n<code>\r\nx = torch.tensor([1, 2, 3], dtype=torch.float32, requires_grad=True)\r\n<\/code>\r\n\r\n3.3 计算梯度\r\n当完成了计算（通常是神经网络的前向传播），并得到一个输出值（通常是损失）后，可以调用该值的.backward()方法来自动计算所有requires_grad=True的Tensors的梯度。\r\n<code>\r\ny = x * x\r\nz = y.sum()\r\nz.backward()  # 这会计算z关于x的梯度\r\n<\/code>\r\n\r\n3.4 查看和操作梯度\r\n用.grad属性查看梯度：\r\n<code>\r\nprint(x.grad)  # 这会显示x的梯度\r\n<\/code>\r\n梯度累加：注意，每次调用.backward()时，梯度都会累加，而不是被替换。这是为了支持RNN等模型的特定情况。如果需要，可以使用.zero_()方法清除累积的梯度。\r\n\r\n3.5 detach()和no_grad()\r\ndetach方法：创建一个与当前Tensor内容相同但不需要梯度的新Tensor。\r\n<code>\r\ndetached_x = x.detach()\r\n<\/code>\r\ntorch.no_grad()上下文：在此上下文中执行的任何操作都不会被跟踪，通常在评估模型时使用这个上下文，因为在这种情况下我们不需要梯度。\r\n<code>\r\nwith torch.no_grad():\r\n    y = x + 2\r\n<\/code>\r\nautograd是PyTorch中非常强大的工具，使得手动计算复杂的梯度成为过去。了解其工作原理和如何使用它是进行有效深度学习的关键。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:6:42",
            "pinned": false
        },
        {
            "id": "25",
            "title": "torch.nn基础学习教程——神经网络基础（转载）",
            "content": "在PyTorch中，神经网络是使用torch.nn包构建的。这个包提供了神经网络的所有核心组件，包括层、损失函数和优化器。\n\n4.1 从nn.Module继承\n核心类：nn.Module是所有神经网络模型和层的基类。当创建自己的网络或层时，需要从这个类继承。\n<code>\nimport torch.nn as nn\n\nclass SimpleNet(nn.Module):\n    def __init__(self):\n        super(SimpleNet, self).__init__()\n<\/code>\n组件初始化：在__init__方法中，你可以定义网络的组件。例如，可以定义线性层、卷积层等。\n<code>\nself.fc1 = nn.Linear(in_features=784, out_features=500)\n<\/code>\n\n4.2 定义前向传播\n自动调用：当你通过网络传递一个输入时，PyTorch会自动调用forward方法。\n定义方式：你应该在此方法中定义数据通过网络的方式。\n<code>\ndef forward(self, x):\n    x = self.fc1(x)\n    return x\n<\/code>\n\n4.3 权重和偏置\n自动管理：在你定义的每个nn.Module组件（如nn.Linear或nn.Conv2d）中，PyTorch会自动为你管理权重和偏置。\n访问方式：\nself.fc1.weight和self.fc1.bias可以分别用来访问fc1层的权重和偏置。\n对于整个网络，可以使用net.parameters()来访问网络中的所有参数（权重和偏置）。\n初始化：虽然PyTorch为每个层提供了默认的初始化，但有时可能需要自定义权重的初始化。nn.init模块提供了一系列初始化方法。\n<code>\nimport torch.nn.init as init\n\ninit.xavier_uniform_(self.fc1.weight)\n<\/code>\n这只是神经网络基础的简要介绍。为了构建真正的深度学习模型，还需要了解其他组件，如激活函数、损失函数、优化器等。但这些基础知识为你提供了一个坚实的起点，从这里开始，你可以继续深入。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:10:18",
            "pinned": false
        },
        {
            "id": "26",
            "title": "torch.nn基础学习教程——定义网络结构（转载）",
            "content": "创建有效的神经网络需要利用多种不同的层和技巧。以下是一些常用的神经网络组件及其在PyTorch中的实现。\r\n\r\n5.1 线性层：nn.Linear\r\n线性层是神经网络的基础，也称为全连接层。\r\n\r\n定义:\r\n<code>\r\nfc = nn.Linear(in_features=128, out_features=64)\r\n<\/code>\r\n其中in_features是输入特征的数量，out_features是输出特征的数量。\r\n5.2 激活函数\r\n激活函数为神经网络引入了非线性性，使其能够学习更复杂的模式。\r\n\r\nReLU:\r\n<code>\r\nrelu = nn.ReLU()\r\n<\/code>\r\nSigmoid:\r\n<code>\r\nsigmoid = nn.Sigmoid()\r\n<\/code>\r\nTanh:\r\n<code>\r\ntanh= nn.Tanh()\r\n<\/code>\r\n\r\n5.3 卷积层：nn.Conv2d\r\n卷积层是卷积神经网络（CNN）的核心，特别适用于图像处理。\r\n\r\n定义:\r\n<code>\r\nconv = nn.Conv2d(in_channels=3, out_channels=64, kernel_size=3, stride=1, padding=1)\r\n<\/code>\r\n其中，in_channels是输入的通道数量，out_channels是输出的通道数量，kernel_size是卷积核的大小。\r\n\r\n5.4 池化层：nn.MaxPool2d\r\n池化层用于降低空间维度，常用于CNN。\r\n\r\n定义:\r\n<code>\r\npool = nn.MaxPool2d(kernel_size=2, stride=2)\r\n<\/code>\r\n\r\n5.5 Dropout：nn.Dropout\r\nDropout是一种正则化技术，用于防止模型过拟合。\r\n\r\n定义:\r\n<code>\r\ndropout = nn.Dropout(p=0.5)\r\n<\/code>\r\n其中，p是dropout的概率，即随机“关闭”神经元的概率。\r\n\r\n5.6 批标准化：nn.BatchNorm2d\r\n批标准化是一种优化技巧，可以使神经网络更快地收敛并提高模型的表现。\r\n\r\n定义:\r\n<code>\r\nbn = nn.BatchNorm2d(num_features=64)\r\n<\/code>\r\n当定义神经网络结构时，组合使用这些组件可以帮助你创建出功能强大的模型。这些基础组件可以为各种任务构建更复杂的网络架构，从图像分类到序列建模等。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:17:3",
            "pinned": false
        },
        {
            "id": "27",
            "title": "torch.nn基础学习教程——损失函数（转载）",
            "content": "损失函数（或称为目标函数、代价函数）衡量模型的预测与真实值之间的差距。在训练神经网络时，目标是最小化这个差距。PyTorch提供了多种内置的损失函数，适用于不同的任务。\n\n6.1 常见的损失函数\n交叉熵损失（Cross Entropy Loss）：通常用于分类问题。\n<code>\ncriterion = nn.CrossEntropyLoss()\n<\/code>\n注意：nn.CrossEntropyLoss同时执行了log softmax和负log likelihood计算。因此，你应该直接给它模型的原始输出，而不是softmax的输出。\n均方误差损失（Mean Squared Error Loss）：常用于回归问题。\n<code>\ncriterion = nn.MSELoss()\n<\/code>\n还有其他损失函数，如nn.L1Loss（平均绝对误差损失），nn.BCELoss（二进制交叉熵损失），nn.SmoothL1Loss（Huber损失）等，可以根据具体任务和需求选择。\n\n6.2 计算损失\n一旦选择了损失函数，计算模型的损失相对直接。\n\n前向传播：首先，通过模型进行前向传播以获得预测值。\n<code>\noutputs = model(inputs)\n<\/code>\n计算损失：然后，使用选定的损失函数计算预测值与实际标签之间的差距。\n<code>\nloss = criterion(outputs, labels)\n<\/code>\n在训练循环中，你会反复计算损失，执行反向传播，并使用优化器更新模型的权重。\n损失函数是训练神经网络的关键部分，因为它们为优化算法提供了明确的目标。选择合适的损失函数是获得高性能模型的关键步骤。\n",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:20:3",
            "pinned": false
        },
        {
            "id": "28",
            "title": "torch.nn基础学习教程——优化器（转载）",
            "content": "优化器在神经网络的训练中起到关键作用。它决定了如何根据损失函数更新网络的权重。PyTorch的torch.optim模块提供了多种常见的优化算法。\r\n7.1 torch.optim介绍\r\ntorch.optim是一个包含多种优化算法的模块。每个优化器都实现了一个常见的优化策略，如梯度下降、动量梯度下降或Adam。\r\n\r\n7.2 SGD, Adam等常用优化器\r\nSGD (随机梯度下降)：最常见的优化算法，有时会加入动量（momentum）进行改进。\r\n<code>\r\noptimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\r\n<\/code>\r\nAdam：一个自适应学习率的优化器，结合了AdaGrad和RMSProp的思想。\r\n<code>\r\noptimizer = torch.optim.Adam(model.parameters(), lr=0.001, betas=(0.9, 0.999), eps=1e-08)\r\n<\/code>\r\n除了SGD和Adam，torch.optim还提供了其他多种优化器，如RMSprop、Adagrad等，供用户选择\r\n\r\n7.3 更新权重\r\n梯度清零：在每次迭代开始时，需要清除之前计算的梯度，否则新的梯度值会被添加到之前的梯度值上。\r\n<code>\r\noptimizer.zero_grad()\r\n<\/code>\r\n反向传播：在计算完损失后，通过调用loss.backward()计算梯度。\r\n<code>\r\nloss.backward()\r\n<\/code>\r\n权重更新：最后，调用优化器的step方法来根据计算的梯度更新权重。\r\n<code>\r\noptimizer.step()\r\n<\/code>\r\n优化器和其参数（如学习率）的选择对模型的训练速度和最终性能都有重要影响。经验和实验对于找到特定任务的最佳优化器和参数设置至关重要。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:23:17",
            "pinned": false
        },
        {
            "id": "29",
            "title": "torch.nn基础学习教程——训练神经网络（转载）",
            "content": "训练是深度学习中最核心的部分，它涉及到将输入数据送入模型并不断调整模型的权重以最小化预测误差。\r\n8.1 数据加载：torch.utils.data.DataLoader\r\n数据加载和处理是深度学习中的一个重要阶段。DataLoader为我们提供了一个简便的工具来自动地进行数据批处理、打乱数据和并行加载数据。\r\n\r\n使用方法:\r\n<code>\r\nfrom torch.utils.data import DataLoader\r\n\r\ntrain_loader = DataLoader(dataset=train_dataset, batch_size=32, shuffle=True, num_workers=4)\r\n<\/code>\r\n其中，train_dataset是一个实现了__len__和__getitem__方法的数据集对象。\r\n\r\n8.2 训练循环\r\n训练循环是深度学习中的核心，涉及到以下步骤：\r\n\r\n前向传播：将数据送入模型并获取预测。\r\n<code>\r\noutputs = model(inputs)\r\n<\/code>\r\n计算损失：根据预测值和真实标签计算损失。\r\n<code>\r\nloss = criterion(outputs, labels)\r\n<\/code>\r\n反向传播：根据损失计算模型的梯度。\r\n<code>\r\noptimizer.zero_grad()  # 清零梯度\r\nloss.backward()        # 反向传播\r\n<\/code>\r\n更新权重：使用优化器更新模型的权重。\r\n<code>\r\noptimizer.step()\r\n<\/code>\r\n\r\n8.3 验证模型性能\r\n在每个训练周期（epoch）结束后，你可能希望在验证数据集上验证模型的性能。这有助于检查模型是否过拟合，并评估其对未见过的数据的泛化能力。\r\n\r\n验证循环：\r\n<code>\r\nmodel.eval()  # 将模型设置为评估模式\r\nwith torch.no_grad():  # 不计算梯度\r\n    for inputs, labels in val_loader:\r\n        outputs = model(inputs)\r\n        val_loss = criterion(outputs, labels)\r\n        # ...计算验证指标（如准确率）\r\nmodel.train()  # 将模型设置回训练模式\r\n<\/code>\r\n训练循环和验证循环是神经网络训练的核心，理解并能够有效地实现这两个循环对于建立一个强大的深度学习模型至关重要。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:27:3",
            "pinned": false
        },
        {
            "id": "30",
            "title": "torch.nn基础学习教程——保存和加载模型（转载）",
            "content": "在PyTorch中，保存和加载模型是一个相对简单的过程。这允许你在不同的时间点保存模型、分享模型或继续中断的训练。\r\n9.1 保存整个模型\r\n这将保存模型的结构和参数。\r\n<code>\r\ntorch.save(model, 'model.pth')\r\n<\/code>\r\n\r\n9.2 仅保存模型参数\r\n通常，你可能只想保存模型的参数（状态字典），而不是整个模型。\r\n<code>\r\ntorch.save(model.state_dict(), 'model_weights.pth')\r\n<\/code>\r\n状态字典 (state_dict) 是一个包含模型所有参数的Python字典对象。这提供了一种轻量级的文件格式，只包含模型的权重。\r\n\r\n9.3 加载模型\r\n加载整个模型：\r\n如果你保存了整个模型，可以使用以下方式加载：\r\n<code>\r\nmodel = torch.load('model.pth')\r\n<\/code>\r\n加载模型参数：\r\n如果你只保存了模型的状态字典，首先你需要创建模型的实例，然后使用load_state_dict方法：\r\n<code>\r\nmodel = YourModelClass(*args, **kwargs)  # 使用与原始模型相同的结构\r\nmodel.load_state_dict(torch.load('model_weights.pth'))\r\n<\/code>\r\n确保加载的state_dict参数与模型的结构匹配。\r\n保存和加载模型是深度学习工作流程的重要部分，无论是为了中断和继续训练，还是为了分享和部署模型。理解如何正确保存和恢复模型可以帮助你避免潜在的问题，并确保你的模型能够按预期工作。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:29:40",
            "pinned": false
        },
        {
            "id": "31",
            "title": "torch.nn基础学习教程——调试及可视化（转载）",
            "content": "深度学习模型训练时，了解模型内部的工作原理和它如何进化是非常重要的。幸运的是，有一些工具可以帮助你调试和可视化你的模型。\r\n10.1 使用torchviz可视化计算图\r\ntorchviz是一个用于可视化PyTorch模型中的计算图的工具。计算图描述了变量之间的关系，这对于理解模型的工作原理和调试非常有用。\r\n\r\n如何使用：\r\n\r\n首先，你需要安装torchviz。\r\n使用torchviz的make_dot函数可视化计算图。\r\n<code>\r\nimport torch\r\nfrom torchviz import make_dot\r\n\r\n# 假设你有一个模型和数据\r\nmodel = YourModelClass()\r\ninputs = torch.randn(1, 3, 224, 224)  # 示例输入\r\noutputs = model(inputs)\r\n\r\n# 可视化计算图\r\ndot = make_dot(outputs)\r\ndot.view()\r\n<\/code>\r\n这将生成一个PDF文件，显示模型的计算图。\r\n\r\n10.2 使用tensorboard进行训练可视化\r\nTensorBoard 是 TensorFlow 的可视化工具，但它也与 PyTorch 兼容，并提供了许多强大的可视化功能。\r\n\r\n如何使用：\r\n\r\n安装 tensorboard 和 torch.utils.tensorboard.\r\n设置 SummaryWriter 来记录数据。\r\n<code>\r\nfrom torch.utils.tensorboard import SummaryWriter\r\n\r\nwriter = SummaryWriter('runs\/experiment_name')\r\n<\/code>\r\n在训练循环中，你可以添加数据记录。\r\n<code>\r\nfor epoch in range(num_epochs):\r\n    # ... training loop ...\r\n    writer.add_scalar('Loss\/train', loss, epoch)\r\n    writer.add_scalar('Accuracy\/train', accuracy, epoch)\r\n<\/code>\r\n使用TensorBoard查看数据。\r\n<code>\r\ntensorboard --logdir=runs\r\n<\/code>\r\n在Web界面中，你可以查看损失、准确性等的变化，以及更多高级功能，如模型结构的可视化、特征空间的投影等。\r\n通过使用这些工具，你可以更好地理解、调试和优化你的模型。在深度学习中，可视化通常是提高模型性能和解决问题的关键。",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 21:31:29",
            "pinned": false
        },
        {
            "id": "32",
            "title": "Java程序设计复习提纲（上：入门语法）（转载）",
            "content": "<h2>基本语法与编译运行<\/h2>\r\n<ol>\r\n<li>java没有指针没有全局变量<\/li>\r\n<li>Java源代码文件的后缀名是\".java\"。编译后会生成一个或多个字节码文件，后缀名为\".class\"。<\/li>\r\n<li>Java的编译器是<code>javac<\/code>，解释器是<code>java<\/code>。使用<code>javac<\/code>编译源代码，然后用<code>java<\/code>运行编译后的字节码。<\/li>\r\n<li>Java中的每一行代码都需要以分号（;）结束。<\/li>\r\n<li>Java语言对大小写敏感，类名的首字母应该大写，而方法名应该以小写字母开头。<\/li>\r\n<li>Java的主方法（程序的入口点）的声明应为：<code>public static void main(String args[])<\/code>。<\/li>\r\n<\/ol>\r\n<h2>数据类型和关键字<\/h2>\r\n<ol>\r\n<li>package语句可以没有，有的话必须放在文件开始的地方<\/li>\r\n<li>public类每个文件中最多有一个<\/li>\r\n<li>Java的注释：单行注释（\/\/）、多行注释（\/*...*\/）和文档注释（\/**...*\/），其中文档注释必须出现在公有类定义或公有方法头前面，为将来的维护人员提供API<\/li>\r\n<li>Java的<code>true<\/code>、<code>false<\/code>、<code>null<\/code>都是小写的<\/li>\r\n<li>Java源码使用的是<code>Unicode<\/code>码，而不是<code>ASCII<\/code>码<\/li>\r\n<li>类名多为名词，含有大小写，首字母要求大写；接口名的命名约定与类名相同<\/li>\r\n<li>Java不允许用数字0,1表示逻辑值<\/li>\r\n<li>Java数据类型：<\/li>\r\n<\/ol>\r\n<p>​        另外字符数据还有string字符串。<code>String<\/code>类提供了许多用于操作字符串的方法，如连接字符串、比较字符串、查找子字符串等。<\/p>\r\n<p>因此，<code>char<\/code>和<code>String<\/code>在Java中都有其用处。如果你只需要处理单个字符，可以使用<code>char<\/code>类型；如果你需要处理一个字符序列，或者需要使用到字符串操作的方法，应该使用<code>String<\/code>类。<\/p>\r\n<p>以下是一些例子：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">char<\/span> c <span class=\"token operator\">=<\/span> <span class=\"token char\">'a'<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ char类型<\/span>\r\n\r\n<span class=\"token class-name\">String<\/span> s <span class=\"token operator\">=<\/span> <span class=\"token string\">\"Hello, world!\"<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ String类型<\/span>\r\n\r\n<span class=\"token comment\">\/\/ 使用String类的方法<\/span>\r\n<span class=\"token keyword\">int<\/span> length <span class=\"token operator\">=<\/span> s<span class=\"token punctuation\">.<\/span><span class=\"token function\">length<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 获取字符串的长度<\/span>\r\n<span class=\"token class-name\">String<\/span> upper <span class=\"token operator\">=<\/span> s<span class=\"token punctuation\">.<\/span><span class=\"token function\">toUpperCase<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 将字符串转换为大写<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"9\">\r\n<li>0开头表示8进制数、0x表示16进制数、077L表示长整型的8进制数<\/li>\r\n<li>Java类型转换主要包括自动类型转换（也叫隐式类型转换）和强制类型转换（也叫显式类型转换）：自动类型转换是指从较小的数据类型自动转换到较大的数据类型（如int转为double）；而强制类型转换则需要在表达式前显式地加上要转换的类型（如double转为int，可能会导致精度丢失）。<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">double<\/span> myDouble <span class=\"token operator\">=<\/span> <span class=\"token number\">9.78<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token keyword\">int<\/span> myInt <span class=\"token operator\">=<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token keyword\">int<\/span><span class=\"token punctuation\">)<\/span> myDouble<span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ 强制类型转换<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"11\">\r\n<li>\r\n<p>在Java中，可以使用四种访问修饰符来修饰类和类的成员（如字段和方法）。这些访问修饰符决定了其他类可以访问的范围。以下是这四种访问修饰符（包括无修饰符，即默认）的访问权限：<\/p>\r\n<div class=\"table-wrapper\"><table>\r\n<thead>\r\n<tr>\r\n<th>访问权限<\/th>\r\n<th>同一类<\/th>\r\n<th>同一包中的子类<\/th>\r\n<th>同一包中的非子类<\/th>\r\n<th>不同包中的子类<\/th>\r\n<th>不同包中的非子类<\/th>\r\n<\/tr>\r\n<\/thead>\r\n<tbody>\r\n<tr>\r\n<td>无修饰符（默认）<\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>否<\/td>\r\n<td>否<\/td>\r\n<\/tr>\r\n<tr>\r\n<td><code>private<\/code><\/td>\r\n<td>是<\/td>\r\n<td>否<\/td>\r\n<td>否<\/td>\r\n<td>否<\/td>\r\n<td>否<\/td>\r\n<\/tr>\r\n<tr>\r\n<td><code>protected<\/code><\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>否<\/td>\r\n<\/tr>\r\n<tr>\r\n<td><code>public<\/code><\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<td>是<\/td>\r\n<\/tr>\r\n<\/tbody>\r\n<\/table><\/div>\r\n<p>(1). <strong>无修饰符（默认）<\/strong>：只能被同一个包内的类访问。<br>\r\n(2). <strong><code>private<\/code><\/strong>：只能在同一类中被访问。<br>\r\n(3). <strong><code>protected<\/code><\/strong>：可以在同一包中的任何类以及其他包中的子类中被访问。<br>\r\n(4). <strong><code>public<\/code><\/strong>：可以在任何地方被访问。<\/p>\r\n<\/li>\r\n<li>\r\n<p>类中定义的公有静态变量相当于全局变量。<\/p>\r\n<\/li>\r\n<li>\r\n<p>在Java中，\"全局变量\"这个术语通常不被使用，因为Java没有像C或C++那样的真正意义上的全局变量。然而，类中定义的公有静态变量（public static variables）在某种意义上可以视为\"全局变量\"，因为它们可以在类的任何实例或者甚至在类的外部被访问和修改。<\/p>\r\n<p>当我们在一个类中声明一个变量为public static时，这就意味着这个变量属于这个类，而不是类的任何一个实例。这个变量在内存中只有一个拷贝，所有的实例都共享这一个变量。<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">MyClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">int<\/span> count <span class=\"token operator\">=<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ 公有静态变量<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>count<\/code>就是一个公有静态变量。我们可以在任何地方通过<code>MyClass.count<\/code>来访问和修改这个变量，无论我们创建了多少个<code>MyClass<\/code>的实例。这就是为什么公有静态变量在某种意义上可以视为\"全局变量\"。<\/p>\r\n<p>但是要注意的是，这并不意味着使用公有静态变量就是一种好的做法。在许多情况下，这样做可能会导致代码更难理解和维护，因为任何代码都可以修改公有静态变量的值，这可能会导致意想不到的副作用和错误。因此，除非有特别的理由，否则通常最好避免使用公有静态变量。<\/p>\r\n<\/li>\r\n<li>\r\n<p><code>void<\/code>是一个关键字，用于指定一个方法不返回任何值。<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">printHello<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Hello, world!\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<\/li>\r\n<\/ol>\r\n<p>15.在处理对象赋值这个问题上，Java和Python实际上有很多相似之处，因为它们都使用引用语义来处理对象。也就是说，当你在Java或Python中将一个对象赋值给另一个变量时，你实际上是在复制对象的引用，而不是整个对象。这意味着赋值后的两个变量指向的是同一个对象，对其中一个变量的任何修改都会影响到另一个变量。<\/p>\r\n<p>然而，Java和Python在如何处理基本数据类型（如整数和浮点数）上有所不同：<\/p>\r\n<ul>\r\n<li>在Java中，基本数据类型（如int，double等）不是对象，它们是直接存储的值。当你将一个基本类型的变量赋值给另一个变量时，Java会复制这个值，而不是引用。因此，修改一个变量不会影响到另一个变量。<\/li>\r\n<li>而在Python中，所有的东西都是对象，包括整数和浮点数。这意味着当你在Python中复制一个整数或浮点数时，你实际上是在复制一个引用。但是，因为Python中的数值类型是不可变的（即你不能修改它们的值），所以在实际使用中，这种差异通常不会引起问题。<\/li>\r\n<\/ul>\r\n<p>在处理数组和其他容器类型时，这种差异就变得更加明显了。例如，如果你在Java中复制一个数组，你会得到一个新的数组，它的元素是原数组的引用。如果你修改了新数组的元素，原数组也会被改变。但是，如果你在Python中复制一个列表，你会得到一个新的列表，它的元素是原列表的引用。如果你修改了新列表的元素，原列表不会被改变。这是因为在Python中，列表的赋值实际上是创建了一个新的列表对象，而这个新列表的元素是原列表的元素的引用。<\/p>\r\n<p>在Java中：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Main<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">main<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> args<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">int<\/span> a <span class=\"token operator\">=<\/span> <span class=\"token number\">5<\/span><span class=\"token punctuation\">;<\/span>\r\n        <span class=\"token keyword\">int<\/span> b <span class=\"token operator\">=<\/span> a<span class=\"token punctuation\">;<\/span>\r\n        a <span class=\"token operator\">=<\/span> <span class=\"token number\">3<\/span><span class=\"token punctuation\">;<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"a: \"<\/span> <span class=\"token operator\">+<\/span> a<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 输出 \"a: 3\"<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"b: \"<\/span> <span class=\"token operator\">+<\/span> b<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 输出 \"b: 5\"<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个Java代码中，我们首先声明了变量<code>a<\/code>并赋值为5，然后声明了变量<code>b<\/code>并将<code>a<\/code>的值赋给它。然后我们改变<code>a<\/code>的值为3。由于Java中的int是基本数据类型，所以<code>b<\/code>的值是<code>a<\/code>在赋值时的值，改变<code>a<\/code>的值并不会影响到<code>b<\/code>。所以最后，<code>a<\/code>的值为3，<code>b<\/code>的值仍为5。<\/p>\r\n<p>在Python中：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-python\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-python\" data-dark-theme=\"true\">a <span class=\"token operator\">=<\/span> <span class=\"token number\">5<\/span>\r\nb <span class=\"token operator\">=<\/span> a\r\na <span class=\"token operator\">=<\/span> <span class=\"token number\">3<\/span>\r\n<span class=\"token keyword\">print<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'a:'<\/span><span class=\"token punctuation\">,<\/span> a<span class=\"token punctuation\">)<\/span>  <span class=\"token comment\"># 输出 \"a: 3\"<\/span>\r\n<span class=\"token keyword\">print<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'b:'<\/span><span class=\"token punctuation\">,<\/span> b<span class=\"token punctuation\">)<\/span>  <span class=\"token comment\"># 输出 \"b: 5\"<\/span>\r\n<\/code><\/pre>\r\n<p>在这个Python代码中，我们首先创建了一个数值对象5并让<code>a<\/code>引用它，然后让<code>b<\/code>引用<code>a<\/code>引用的对象。然后我们创建了一个新的数值对象3并让<code>a<\/code>引用它。Python的数值对象是不可变的，所以我们实际上是创建了一个新的数值对象，而不是修改了原来的数值对象。因此，改变<code>a<\/code>的引用并不会影响到<code>b<\/code>。所以最后，<code>a<\/code>的值为3，<code>b<\/code>的值仍为5。<\/p>\r\n<p>总的来说，不论是在Java还是Python中，修改原始变量并不会影响到被赋值的变量。这是因为在这两种语言中，数值赋值都是通过创建新的数值对象实现的，而不是直接修改原来的数值对象。<\/p>\r\n<ol start=\"16\">\r\n<li>在Java中，成员变量（也称为字段、属性或实例变量）和静态变量会有默认初始化，而局部变量则必须显式初始化才能使用。<\/li>\r\n<\/ol>\r\n<ul>\r\n<li><strong>成员变量和静态变量<\/strong>：如果你在类中声明一个字段但没有给它赋值，Java会为其提供一个默认值。具体默认值取决于字段的数据类型。例如，数字类型的默认值是0，布尔类型的默认值是false，引用类型（类、接口等）的默认值是null。<\/li>\r\n<li><strong>局部变量<\/strong>：这是在方法、构造函数或者代码块中定义的变量。局部变量在使用前必须显式初始化，否则编译器将报错。这是因为局部变量存储在栈上，而不是像成员变量和静态变量那样存储在堆上，Java不会为栈上的变量提供默认值。<\/li>\r\n<\/ul>\r\n<p>例如，以下的Java代码将无法编译：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Main<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">main<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> args<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">int<\/span> a<span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 这是一个局部变量<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span>a<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 编译错误：变量a可能尚未初始化<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>你需要先给变量<code>a<\/code>赋值，才能使用它：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Main<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">main<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> args<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">int<\/span> a <span class=\"token operator\">=<\/span> <span class=\"token number\">5<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 这是一个局部变量<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span>a<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 输出：5<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<h2 id=\"常用语法\">常用语法<\/h2>\r\n<ol>\r\n<li>逻辑运算符<\/li>\r\n<\/ol>\r\n<p>Java中的逻辑运算符主要有以下几种：<\/p>\r\n<p>（1）. <code>&amp;&amp;<\/code>：逻辑与（AND）运算符。当且仅当两个操作数都为true时，结果才为true。例如：<code>(5 &gt; 3) &amp;&amp; (2 &gt; 3)<\/code>的结果是false。<br>\r\n（2）. <code>||<\/code>：逻辑或（OR）运算符。只要两个操作数中有一个为true，结果就为true。例如：<code>(5 &gt; 3) || (2 &gt; 3)<\/code>的结果是true。<br>\r\n（3）. <code>!<\/code>：逻辑非（NOT）运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将使其为false。例如：<code>!(5 &gt; 3)<\/code>的结果是false。<\/p>\r\n<p>值得注意的是，Java中的<code>&amp;&amp;<\/code>和<code>||<\/code>运算符都具有\"短路\"行为。这意味着，如果左边的操作数已经足够确定整个表达式的值，那么右边的操作数就不会被计算。例如，在<code>true || (x &gt; y)<\/code>表达式中，不论<code>(x &gt; y)<\/code>的值是什么，整个表达式的结果都是true，因此<code>(x &gt; y)<\/code>不会被计算。同理，在<code>false &amp;&amp; (x &gt; y)<\/code>表达式中，<code>(x &gt; y)<\/code>也不会被计算。这种特性可以用来防止程序中的某些计算产生副作用。<\/p>\r\n<ol start=\"2\">\r\n<li>控制流语句<\/li>\r\n<\/ol>\r\n<p>在Java中，<code>if<\/code>、<code>for<\/code>、<code>while<\/code>、<code>switch<\/code>等都是控制流语句，用于控制程序的执行流程。以下是他们的基本语法：<\/p>\r\n<ul>\r\n<li><strong>if语句<\/strong>：用于根据指定的条件执行代码。<\/li>\r\n<\/ul>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">if<\/span> <span class=\"token punctuation\">(<\/span>condition<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ 代码块1<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">else<\/span> <span class=\"token keyword\">if<\/span> <span class=\"token punctuation\">(<\/span>anotherCondition<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ 代码块2<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">else<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ 代码块3<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<ul>\r\n<li><strong>for循环<\/strong>：用于重复执行某段代码一定的次数。<\/li>\r\n<\/ul>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">for<\/span> <span class=\"token punctuation\">(<\/span>initialization<span class=\"token punctuation\">;<\/span> condition<span class=\"token punctuation\">;<\/span> update<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ 代码块<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<ul>\r\n<li><strong>while循环<\/strong>：用于在满足特定条件时重复执行代码。<\/li>\r\n<\/ul>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">while<\/span> <span class=\"token punctuation\">(<\/span>condition<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ 代码块<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<ul>\r\n<li><strong>do...while循环<\/strong>：类似于while循环，但至少会执行一次代码块。<\/li>\r\n<\/ul>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">do<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ 代码块<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">while<\/span> <span class=\"token punctuation\">(<\/span>condition<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ul>\r\n<li><strong>switch语句<\/strong>：用于根据变量或表达式的值来执行特定的代码块。<\/li>\r\n<\/ul>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">switch<\/span> <span class=\"token punctuation\">(<\/span>expression<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">case<\/span> value1<span class=\"token operator\">:<\/span>\r\n        <span class=\"token comment\">\/\/ 代码块1<\/span>\r\n        <span class=\"token keyword\">break<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token keyword\">case<\/span> value2<span class=\"token operator\">:<\/span>\r\n        <span class=\"token comment\">\/\/ 代码块2<\/span>\r\n        <span class=\"token keyword\">break<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token keyword\">default<\/span><span class=\"token operator\">:<\/span>\r\n        <span class=\"token comment\">\/\/ 代码块3<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>请注意，这些控制流语句可以根据需要进行嵌套使用。<\/p>\r\n<ol start=\"3\">\r\n<li>\r\n<p><code>break<\/code>语句用于完全结束循环，无论循环条件是否仍然为真。它通常用于提前退出循环。一旦<code>break<\/code>语句被执行，控制流将立即跳出当前的循环体，并继续执行循环后面的语句。<br>\r\n<code>continue<\/code>语句用于跳过当前循环的剩余部分，直接进入下一次循环。与<code>break<\/code>不同，<code>continue<\/code>并不会完全终止循环，它只是提前开始下一次循环。<br>\r\n<code>break<\/code>和<code>continue<\/code>都是用来改变循环的正常执行流程的。<code>break<\/code>用于完全退出循环，而<code>continue<\/code>用于跳过当前循环的剩余部分并进入下一次循环。<\/p>\r\n<\/li>\r\n<li>\r\n<p>输入输出：Java的标准输入和输出主要依赖于java.util.Scanner类和System类。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p><strong>输入<\/strong><\/p>\r\n<p>java.util.Scanner是一个简单的文本扫描器，可以解析原始类型和字符串的使用空格作为分隔符的文本。<\/p>\r\n<p>以下是一个简单的使用Scanner从标准输入读取数据的例子：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">import<\/span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.<\/span>util<span class=\"token punctuation\">.<\/span><\/span><span class=\"token class-name\">Scanner<\/span><\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 导入Scanner类<\/span>\r\n\r\n<span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Main<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">main<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> args<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">Scanner<\/span> scanner <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Scanner<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>in<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 创建一个新的Scanner对象，接收从标准输入读入的数据<\/span>\r\n\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"请输入一个数字：\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n        <span class=\"token keyword\">int<\/span> number <span class=\"token operator\">=<\/span> scanner<span class=\"token punctuation\">.<\/span><span class=\"token function\">nextInt<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 读取用户输入的整数<\/span>\r\n\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"你输入的数字是：\"<\/span> <span class=\"token operator\">+<\/span> number<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p><strong>输出<\/strong><\/p>\r\n<p>System.out是一个PrintStream类型的对象，它通常用于输出文本数据到标准输出（通常是控制台）。<\/p>\r\n<p>以下是使用System.out.println输出数据的例子：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Main<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">main<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> args<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Hello, world!\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 输出字符串到标准输出<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p><code>System.out.println<\/code>可以接收各种类型的参数，包括字符串、整数、浮点数等，它会将这些参数转换为字符串并输出到标准输出。如果你只是想输出文本但不想在后面加上换行符，可以使用<code>System.out.print<\/code>方法。<\/p>\r\n<h2 id=\"数组与字符串\">数组与字符串<\/h2>\r\n<h3 id=\"数组\">数组<\/h3>\r\n<p>在Java中，数组是同一类型数据的有序集合。<\/p>\r\n<p>以下是Java数组的主要知识点：<\/p>\r\n<ol>\r\n<li><strong>声明数组<\/strong>：在Java中，你可以使用以下语法声明数组：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\">dataType<span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> arrayName<span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 声明<\/span>\r\n<\/code><\/pre>\r\n<p>例如，声明一个整数数组：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> myArray<span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"2\">\r\n<li><strong>创建数组<\/strong>：一旦数组被声明，你需要使用<code>new<\/code>关键字创建数组：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\">arrayName <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> dataType<span class=\"token punctuation\">[<\/span>arraySize<span class=\"token punctuation\">]<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 创建<\/span>\r\n<\/code><\/pre>\r\n<p>例如，创建一个可以存储5个整数的数组：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\">myArray <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token keyword\">int<\/span><span class=\"token punctuation\">[<\/span><span class=\"token number\">5<\/span><span class=\"token punctuation\">]<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"3\">\r\n<li><strong>初始化数组<\/strong>：你可以在声明时就初始化数组：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\">dataType<span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> arrayName <span class=\"token operator\">=<\/span> <span class=\"token punctuation\">{<\/span>element1<span class=\"token punctuation\">,<\/span> element2<span class=\"token punctuation\">,<\/span> element3<span class=\"token punctuation\">,<\/span> <span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<p>例如，声明并初始化一个整数数组：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> myArray <span class=\"token operator\">=<\/span> <span class=\"token punctuation\">{<\/span><span class=\"token number\">1<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">2<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">3<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">4<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">5<\/span><span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<p>或者，你也可以在创建数组后分别为每个元素赋值：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\">myArray<span class=\"token punctuation\">[<\/span><span class=\"token number\">0<\/span><span class=\"token punctuation\">]<\/span> <span class=\"token operator\">=<\/span> <span class=\"token number\">1<\/span><span class=\"token punctuation\">;<\/span>\r\nmyArray<span class=\"token punctuation\">[<\/span><span class=\"token number\">1<\/span><span class=\"token punctuation\">]<\/span> <span class=\"token operator\">=<\/span> <span class=\"token number\">2<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"4\">\r\n<li><strong>访问数组元素<\/strong>：你可以通过索引来访问数组元素：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\">arrayName<span class=\"token punctuation\">[<\/span>index<span class=\"token punctuation\">]<\/span>\r\n<\/code><\/pre>\r\n<p>例如，访问数组的第一个元素：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span> firstElement <span class=\"token operator\">=<\/span> myArray<span class=\"token punctuation\">[<\/span><span class=\"token number\">0<\/span><span class=\"token punctuation\">]<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"5\">\r\n<li><strong>数组长度<\/strong>：你可以使用<code>length<\/code>属性来获取数组的长度：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span> length <span class=\"token operator\">=<\/span> arrayName<span class=\"token punctuation\">.<\/span>length<span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<p>例如，获取数组的长度：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span> length <span class=\"token operator\">=<\/span> myArray<span class=\"token punctuation\">.<\/span>length<span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"6\">\r\n<li><strong>遍历数组<\/strong>：你可以使用for循环或者for-each循环来遍历数组。例如：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">for<\/span><span class=\"token punctuation\">(<\/span><span class=\"token keyword\">int<\/span> i<span class=\"token operator\">=<\/span><span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span> i <span class=\"token operator\">&lt;<\/span> myArray<span class=\"token punctuation\">.<\/span>length<span class=\"token punctuation\">;<\/span> i<span class=\"token operator\">++<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span>myArray<span class=\"token punctuation\">[<\/span>i<span class=\"token punctuation\">]<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n\r\n<span class=\"token keyword\">for<\/span><span class=\"token punctuation\">(<\/span><span class=\"token keyword\">int<\/span> element <span class=\"token operator\">:<\/span> myArray<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span>element<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"7\">\r\n<li><strong>多维数组<\/strong>：Java也支持多维数组，最常见的是二维数组：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> my2DArray <span class=\"token operator\">=<\/span> <span class=\"token punctuation\">{<\/span><span class=\"token punctuation\">{<\/span><span class=\"token number\">1<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">2<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">3<\/span><span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token punctuation\">{<\/span><span class=\"token number\">4<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">5<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">6<\/span><span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token punctuation\">{<\/span><span class=\"token number\">7<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">8<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">9<\/span><span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<p>这些是Java数组的基本知识点。数组是Java中非常重要的数据结构，用于存储和操作大量同类型的数据。<\/p>\r\n<p>基本的数组操作，如初始化、访问、修改元素、获取数组长度等，都是通过索引操作或者使用<code>length<\/code>属性来完成的.<\/p>\r\n<h3 id=\"字符串\">字符串<\/h3>\r\n<p>在 Java 中，字符串是一个非常常用的对象类型，用于存储和操作文本。以下是 Java 字符串的一些主要知识点：<\/p>\r\n<ol>\r\n<li><strong>创建字符串<\/strong>：你可以使用双引号 (\"\") 来创建一个字符串字面量：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token class-name\">String<\/span> str <span class=\"token operator\">=<\/span> <span class=\"token string\">\"Hello, world!\"<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<p>或者，你也可以使用 <code>new<\/code> 关键字来创建一个字符串对象：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token class-name\">String<\/span> str <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">String<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Hello, world!\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"2\">\r\n<li><strong>字符串长度<\/strong>：你可以使用 <code>length()<\/code> 方法来获取字符串的长度：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span> len <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">length<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"3\">\r\n<li><strong>连接字符串<\/strong>：你可以使用 <code>+<\/code> 运算符或者 <code>concat()<\/code> 方法来连接两个字符串：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token class-name\">String<\/span> str1 <span class=\"token operator\">=<\/span> <span class=\"token string\">\"Hello\"<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token class-name\">String<\/span> str2 <span class=\"token operator\">=<\/span> <span class=\"token string\">\"world\"<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token class-name\">String<\/span> str3 <span class=\"token operator\">=<\/span> str1 <span class=\"token operator\">+<\/span> <span class=\"token string\">\" \"<\/span> <span class=\"token operator\">+<\/span> str2<span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 使用 + 运算符<\/span>\r\n<span class=\"token class-name\">String<\/span> str4 <span class=\"token operator\">=<\/span> str1<span class=\"token punctuation\">.<\/span><span class=\"token function\">concat<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\" \"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">.<\/span><span class=\"token function\">concat<\/span><span class=\"token punctuation\">(<\/span>str2<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 使用 concat() 方法<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"4\">\r\n<li><strong>比较字符串<\/strong>：你可以使用 <code>equals()<\/code> 方法或者 <code>equalsIgnoreCase()<\/code> 方法来比较两个字符串是否相等：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">boolean<\/span> isEqual <span class=\"token operator\">=<\/span> str1<span class=\"token punctuation\">.<\/span><span class=\"token function\">equals<\/span><span class=\"token punctuation\">(<\/span>str2<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 区分大小写<\/span>\r\n<span class=\"token keyword\">boolean<\/span> isEqualIgnoreCase <span class=\"token operator\">=<\/span> str1<span class=\"token punctuation\">.<\/span><span class=\"token function\">equalsIgnoreCase<\/span><span class=\"token punctuation\">(<\/span>str2<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 不区分大小写<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"5\">\r\n<li><strong>字符串子串<\/strong>：你可以使用 <code>substring()<\/code> 方法来获取字符串的子串：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token class-name\">String<\/span> substr <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">substring<\/span><span class=\"token punctuation\">(<\/span>startIndex<span class=\"token punctuation\">,<\/span> endIndex<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 索引从 0 开始，包含开始索引，不包含结束索引<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"6\">\r\n<li><strong>查找字符或子串<\/strong>：你可以使用 <code>indexOf()<\/code> 方法或者 <code>lastIndexOf()<\/code> 方法来查找字符或子串在字符串中的位置：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">int<\/span> index <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">indexOf<\/span><span class=\"token punctuation\">(<\/span><span class=\"token char\">'o'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 返回字符 'o' 第一次出现的位置<\/span>\r\n<span class=\"token keyword\">int<\/span> lastIndex <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">lastIndexOf<\/span><span class=\"token punctuation\">(<\/span><span class=\"token char\">'o'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 返回字符 'o' 最后一次出现的位置<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"7\">\r\n<li><strong>替换字符或子串<\/strong>：你可以使用 <code>replace()<\/code> 方法来替换字符串中的字符或子串：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token class-name\">String<\/span> newStr <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">replace<\/span><span class=\"token punctuation\">(<\/span><span class=\"token char\">'o'<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token char\">'a'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 将所有的 'o' 替换为 'a'<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"8\">\r\n<li><strong>字符串分割<\/strong>：你可以使用 <code>split()<\/code> 方法来根据指定的分隔符分割字符串：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token class-name\">String<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> parts <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">split<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\" \"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ 使用空格作为分隔符<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"9\">\r\n<li><strong>字符串转换<\/strong>：你可以使用 <code>toLowerCase()<\/code>、<code>toUpperCase()<\/code> 方法来将字符串转换为小写或大写：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token class-name\">String<\/span> lowerCaseStr <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">toLowerCase<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token class-name\">String<\/span> upperCaseStr <span class=\"token operator\">=<\/span> str<span class=\"token punctuation\">.<\/span><span class=\"token function\">toUpperCase<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<h2 id=\"异常处理\">异常处理<\/h2>\r\n<p>在Java中，异常是在程序执行期间发生的问题的对象表示。Java使用异常来表示错误，以便程序可以捕获并处理它们。以下是Java异常的主要知识点：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>异常类型<\/strong>：在Java中，所有的异常类型都是<code>java.lang.Throwable<\/code>类的子类。它有两个主要的子类：<code>java.lang.Error<\/code>和<code>java.lang.Exception<\/code>。<code>Error<\/code>类表示的是程序无法处理的严重问题，如系统崩溃、虚拟机错误等，程序通常不处理这类错误。<code>Exception<\/code>类表示的是程序可以处理的异常，它又分为两种：检查型异常（checked exceptions）和非检查型异常（unchecked exceptions）。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>抛出异常<\/strong>：你可以使用<code>throw<\/code>关键字来抛出一个异常。例如：<\/p>\r\n<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">throw<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Exception<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"This is an exception\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"3\">\r\n<li><strong>捕获异常<\/strong>：你可以使用<code>try-catch<\/code>语句来捕获并处理异常。例如：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">try<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ some code that may throw an exception<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">catch<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token class-name\">Exception<\/span> e<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ handle the exception<\/span>\r\n    <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span>e<span class=\"token punctuation\">.<\/span><span class=\"token function\">getMessage<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"4\">\r\n<li><strong>finally块<\/strong>：<code>finally<\/code>块包含的代码无论是否发生异常都会被执行，常用于资源的清理工作。例如：<\/li>\r\n<\/ol>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">try<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ some code that may throw an exception<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">catch<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token class-name\">Exception<\/span> e<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ handle the exception<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">finally<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ cleanup code here<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<ol start=\"5\">\r\n<li>\r\n<p><strong>自定义异常<\/strong>：你可以通过扩展<code>Exception<\/code>类（或其子类）来创建自定义的异常类。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>异常链<\/strong>：你可以使用<code>initCause()<\/code>方法或者在构造函数中提供一个cause参数来设置一个异常的原因，这样就可以形成一个异常链，它可以提供更详细的错误信息。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p>当Java中的代码抛出一个异常时，程序的正常执行流程会被中断，然后立即跳转到匹配该异常类型的<code>catch<\/code>块。<\/p>\r\n<p>以下是具体的步骤：<\/p>\r\n<ol>\r\n<li>\r\n<p>当一个异常在<code>try<\/code>块中被抛出时，程序的控制权将立即转移到第一个匹配该异常类型的<code>catch<\/code>块。这意味着在异常被抛出之后的<code>try<\/code>块中的任何代码都不会被执行。<\/p>\r\n<\/li>\r\n<li>\r\n<p>如果找到一个匹配的<code>catch<\/code>块，那么它的内部代码将被执行。这通常涉及到错误处理逻辑，例如记录错误、清理资源、通知用户等。<\/p>\r\n<\/li>\r\n<li>\r\n<p>如果<code>try<\/code>\/<code>catch<\/code>块后面有<code>finally<\/code>块，那么不管是否捕获到异常，<code>finally<\/code>块中的代码都将被执行。这常用于资源的清理工作，例如关闭文件、释放内存等。<\/p>\r\n<\/li>\r\n<li>\r\n<p>在所有的<code>catch<\/code>和<code>finally<\/code>块执行完毕后，程序控制权将返回到<code>try<\/code>\/<code>catch<\/code>\/<code>finally<\/code>块之后的代码，然后程序将继续正常执行。<\/p>\r\n<\/li>\r\n<li>\r\n<p>如果在<code>try<\/code>块中抛出的异常没有被任何<code>catch<\/code>块捕获，那么该异常将会被传播到上一级方法中，如果上一级方法也没有捕获该异常，那么该异常将继续向上传播，直到被捕获或者达到程序的最顶层。如果一个异常到达了程序的最顶层还没有被捕获，那么程序将会终止，并打印出异常的堆栈跟踪信息。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p>下面是一个例子，演示了异常的捕获和处理：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" data-dark-theme=\"true\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\" data-dark-theme=\"true\"><span class=\"token keyword\">try<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">int<\/span> a <span class=\"token operator\">=<\/span> <span class=\"token number\">5<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token keyword\">int<\/span> b <span class=\"token operator\">=<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token keyword\">int<\/span> c <span class=\"token operator\">=<\/span> a <span class=\"token operator\">\/<\/span> b<span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ This line will throw an ArithmeticException<\/span>\r\n    <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span>c<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">catch<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token class-name\">ArithmeticException<\/span> e<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"An error occurred: \"<\/span> <span class=\"token operator\">+<\/span> e<span class=\"token punctuation\">.<\/span><span class=\"token function\">getMessage<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span> <span class=\"token keyword\">finally<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"This is the finally block.\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，当尝试除以0时，将会抛出一个<code>ArithmeticException<\/code>，这将中断程序的正常执行流程，然后立即跳转到<code>catch<\/code>块。在<code>catch<\/code>块中，程序打印出一个错误消息。然后，不管是否发生了异常，<code>finally<\/code>块中的代码都会被执行。<\/p>",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 22:8:19",
            "pinned": false
        },
        {
            "id": "33",
            "title": "Java程序设计复习提纲（中：面向对象）（转载）",
            "content": "<h2 id=\"面向对象概述\">面向对象概述<\/h2>\r\n<p>面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，它使用“对象”来设计软件和实现复杂的软件系统。在OOP中，每个对象都是一个特定类（class）或类型（type）的实例，类定义了对象的数据和可以对这些数据执行的操作。<\/p>\r\n<p>下面是面向对象编程的一些主要概念：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>类（Class）<\/strong>：类是对象的蓝图或模板。一个类定义了创建对象时其数据的类型和可用的方法。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>对象（Object）<\/strong>：对象是类的实例。每个对象都有其自己的状态和行为。状态由属性（也称为字段或变量）表示，行为由方法（也称为函数）表示。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>继承（Inheritance）<\/strong>：继承是一种机制，可以创建一个新类（子类）来继承一个已存在的类（父类）的属性和方法。子类可以添加新的属性和方法，也可以重写父类的方法。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>封装（Encapsulation）<\/strong>：封装是将对象的状态（属性）和行为（方法）打包在一起，并隐藏对象内部的实现细节。通过封装，可以保护对象的内部状态不被外部直接访问，只能通过对象提供的方法来访问。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>多态（Polymorphism）<\/strong>：多态是指允许一个接口被多种实际类型实现。在OOP中，多态允许我们以统一的方式处理不同类型的对象，只要它们都实现了相同的方法或接口。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p>如果你学过Python，那么你应该已经接触过面向对象编程，因为Python也是一种支持OOP的语言。例如，你可能已经定义过自己的类，创建过对象，或者使用过继承。下面是一个简单的Python类的例子：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-python\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-python\"><span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">:<\/span>\r\n    <span class=\"token keyword\">def<\/span> <span class=\"token function\">__init__<\/span><span class=\"token punctuation\">(<\/span>self<span class=\"token punctuation\">,<\/span> name<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">:<\/span>\r\n        self<span class=\"token punctuation\">.<\/span>name <span class=\"token operator\">=<\/span> name\r\n\r\n    <span class=\"token keyword\">def<\/span> <span class=\"token function\">bark<\/span><span class=\"token punctuation\">(<\/span>self<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">:<\/span>\r\n        <span class=\"token keyword\">print<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Woof, my name is \"<\/span> <span class=\"token operator\">+<\/span> self<span class=\"token punctuation\">.<\/span>name<span class=\"token punctuation\">)<\/span>\r\n\r\nfido <span class=\"token operator\">=<\/span> Dog<span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Fido\"<\/span><span class=\"token punctuation\">)<\/span>\r\nfido<span class=\"token punctuation\">.<\/span>bark<span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span>  <span class=\"token comment\"># prints \"Woof, my name is Fido\"<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>是一个类，它有一个属性<code>name<\/code>和一个方法<code>bark<\/code>。然后我们创建了一个<code>Dog<\/code>的实例<code>fido<\/code>，并调用了它的<code>bark<\/code>方法。<\/p>\r\n<p>在Java中，面向对象编程的概念和使用方法与Python类似。以下是一个Java版本的同样的狗狗类：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">private<\/span> <span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">;<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span>name <span class=\"token operator\">=<\/span> name<span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">bark<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Woof, my name is \"<\/span> <span class=\"token operator\">+<\/span> <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span>name<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">main<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span><span class=\"token punctuation\">[<\/span><span class=\"token punctuation\">]<\/span> args<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">Dog<\/span> fido <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Fido\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n        fido<span class=\"token punctuation\">.<\/span><span class=\"token function\">bark<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ prints \"Woof, my name is Fido\"<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个Java版本的例子中，<code>Dog<\/code>仍然是一个类，它有一个私有属性<code>name<\/code>和一个公有方法<code>bark<\/code>。然后我们在<code>main<\/code>方法中创建了一个<code>Dog<\/code>的实例<code>fido<\/code>，并调用了它的<code>bark<\/code>方法。<\/p>\r\n<p>你可以看到，虽然两种语言的语法不同，但是面向对象编程的主要概念在两种语言中都是相同的。<\/p>\r\n<h2 id=\"类的概念\">类的概念<\/h2>\r\n<p>类（Class）是Java中的核心概念，它是面向对象编程的基础。以下是关于Java类的一些主要知识点：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>基本概念<\/strong>：在Java中，类是一个模板，定义了一类对象的属性（也称为字段或成员变量）和方法（也称为函数或成员函数）。对象是类的实例，代表了类的一个特定实例。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>定义一个类<\/strong>：在Java中，定义一个类的基本语法如下：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">MyClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ fields (variables)<\/span>\r\n    <span class=\"token keyword\">private<\/span> <span class=\"token keyword\">int<\/span> myField<span class=\"token punctuation\">;<\/span>\r\n\r\n    <span class=\"token comment\">\/\/ methods<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">myMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token comment\">\/\/ method body<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>这定义了一个名为<code>MyClass<\/code>的类，包含一个私有字段<code>myField<\/code>和一个公共方法<code>myMethod<\/code>。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>对象的创建<\/strong>：使用<code>new<\/code>关键字和构造函数可以创建类的新实例。例如：<code>MyClass obj = new MyClass();<\/code>会创建一个<code>MyClass<\/code>的新对象，并将其赋值给<code>obj<\/code>。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>构造函数<\/strong>：构造函数是一种特殊的方法，用于初始化新创建的对象。构造函数的名称必须与类名相同，且没有返回类型。如果未在类中明确定义构造函数，Java会提供一个默认的无参数构造函数。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>this关键字<\/strong>：在类的方法中，<code>this<\/code>关键字用于引用调用当前方法的对象。它常常用在构造函数和设置器（setter）方法中，以区分成员变量和参数。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>static关键字<\/strong>：<code>static<\/code>关键字可以用于定义类级别的变量和方法。静态变量（也称为类变量）在所有对象之间共享，静态方法（也称为类方法）可以在没有对象的情况下直接通过类名调用。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<h2 id=\"对象的构造和初始化\">对象的构造和初始化<\/h2>\r\n<p>在Java中，对象的创建和初始化涉及到以下几个关键的概念：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>对象的创建<\/strong>：在Java中，使用<code>new<\/code>关键字和构造器（constructor）来创建一个新的对象。例如，<code>new Dog(\"Fido\")<\/code>会创建一个新的<code>Dog<\/code>对象。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>构造方法<\/strong>：构造方法是一种特殊类型的方法，用于创建和初始化对象。构造方法的名称必须与类名相同，且没有返回值（也不用声明void）。构造方法可以接受参数，这些参数用于初始化新创建的对象。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">private<\/span> <span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">;<\/span>\r\n\r\n    <span class=\"token comment\">\/\/ This is a constructor<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span>name <span class=\"token operator\">=<\/span> name<span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>类的构造方法接受一个<code>name<\/code>参数，用于初始化<code>Dog<\/code>对象的<code>name<\/code>属性。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>this引用<\/strong>：在Java中，<code>this<\/code>是一个特殊的变量，它引用的是当前对象。在构造方法或其他实例方法中，你可以使用<code>this<\/code>来引用当前对象的属性或方法。例如，在上面的<code>Dog<\/code>类的构造方法中，<code>this.name = name<\/code>表示将构造方法的参数<code>name<\/code>赋值给当前对象的<code>name<\/code>属性。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>初始化块<\/strong>：Java中还有一种特殊的“初始化块”（也称为“实例初始化块”），它在创建对象时运行，但是在构造方法之前。初始化块在每次创建对象时都会执行，而且它能访问所有的字段和方法，包括private。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">private<\/span> <span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">;<\/span>\r\n\r\n    <span class=\"token comment\">\/\/ This is an initializer block<\/span>\r\n    <span class=\"token punctuation\">{<\/span>\r\n        name <span class=\"token operator\">=<\/span> <span class=\"token string\">\"Unknown\"<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token comment\">\/\/ This is a constructor<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span>name <span class=\"token operator\">=<\/span> name<span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，初始化块会在每次创建<code>Dog<\/code>对象时执行，并将<code>name<\/code>属性设置为\"Unknown\"。然后构造方法会运行，并可能将<code>name<\/code>属性更改为其他值。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>默认构造方法<\/strong>：默认构造方法是Java类在没有定义任何构造方法时，编译器自动为其提供的一个无参数的构造方法。默认构造方法的主要任务是创建类的一个新实例。<\/p>\r\n<p>如果你在一个类中没有显式地定义任何构造方法，那么Java编译器会为你提供一个默认的构造方法。这个默认的构造方法没有参数，也没有任何执行语句。<\/p>\r\n<p>以下是一个例子：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ No constructor is defined here<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，我们并没有为<code>Dog<\/code>类定义任何构造方法，所以Java编译器会自动为我们提供一个默认的构造方法。这个默认的构造方法等同于以下的无参数构造方法：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token comment\">\/\/ No initialization code<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>但是，一旦你为一个类定义了至少一个构造方法（不管这个构造方法是否有参数），那么Java编译器就不再提供默认的构造方法。在这种情况下，如果你还想拥有一个无参数的构造方法，你需要显式地定义它。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p>以上是Java对象构造和初始化的基本概念和用法。理解这些概念对于编写Java程序是非常重要的。<\/p>\r\n<h2 id=\"继承\">继承<\/h2>\r\n<p>在Java中，子类和继承是面向对象编程的核心概念。以下是这些概念的一些基本点：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>继承<\/strong>：在Java中，一个类可以从另一个类继承字段和方法。这个被继承的类被称为父类或超类，继承它的类被称为子类。继承用关键字<code>extends<\/code>来表示。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">eat<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The animal eats\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n\r\n<span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token keyword\">extends<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ Dog class inherits from Animal class<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>类是<code>Animal<\/code>类的子类，它继承了<code>Animal<\/code>类的<code>eat<\/code>方法。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>方法重写<\/strong>：子类可以重写继承自父类的方法，以提供不同的实现。方法重写是多态的一种表现形式。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token keyword\">extends<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token annotation punctuation\">@Override<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">eat<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The dog eats\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>类重写了<code>Animal<\/code>类的<code>eat<\/code>方法，提供了不同的实现。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>super关键字<\/strong>：子类可以使用<code>super<\/code>关键字来引用父类的字段和方法。这在子类需要访问父类的实现时非常有用。例如，子类可以使用<code>super<\/code>关键字来调用父类的构造方法。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Animal<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"An animal has been created\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n\r\n<span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token keyword\">extends<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">super<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ Call the constructor of the superclass (Animal)<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"A dog has been created\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>类的构造方法调用了<code>Animal<\/code>类的构造方法。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>公有方法读取<\/strong>：在Java中，子类不能直接访问父类的私有字段和方法。这是由Java的访问控制机制决定的，私有成员（字段或方法）仅在其所在的类内部可见。<\/p>\r\n<p>然而，子类可以通过继承的公有或保护方法访问和修改父类的私有字段，或者调用父类的私有方法。这些公有或保护方法被视为父类的公有接口或者是受保护的接口，子类可以通过这些接口与父类的私有成员进行交互。这样做的好处是封装性和数据隐藏，使得类的内部实现可以独立于外部接口进行改变，而不影响到使用该类的代码。<\/p>\r\n<p>以下是一个例子：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">private<\/span> <span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">;<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Animal<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span>name <span class=\"token operator\">=<\/span> name<span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token comment\">\/\/ Public getter for the private field<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">String<\/span> <span class=\"token function\">getName<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">return<\/span> <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span>name<span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token comment\">\/\/ Public setter for the private field<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">setName<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span>name <span class=\"token operator\">=<\/span> name<span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n\r\n<span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token keyword\">extends<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span> name<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">super<\/span><span class=\"token punctuation\">(<\/span>name<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">printName<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token comment\">\/\/ Accessing the private field of the superclass through a public method<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The dog's name is \"<\/span> <span class=\"token operator\">+<\/span> <span class=\"token function\">getName<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>类不能直接访问<code>Animal<\/code>类的私有字段<code>name<\/code>，但是它可以通过<code>Animal<\/code>类的公有方法<code>getName<\/code>和<code>setName<\/code>来获取和修改<code>name<\/code>字段的值。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<h2 id=\"方法重写\">方法重写<\/h2>\r\n<p>Java中的方法重写（也称为方法覆盖）是子类提供父类已有方法的不同实现的机制。这是多态性的一个重要方面。以下是关于方法重写的一些关键点：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>基本概念<\/strong>：当子类需要改变父类方法的行为时，子类可以提供与父类方法具有相同名称和参数的方法。这种行为称为方法重写。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">makeSound<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The animal makes a sound\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n\r\n<span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token keyword\">extends<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token annotation punctuation\">@Override<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">makeSound<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The dog barks\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>类重写了<code>Animal<\/code>类的<code>makeSound<\/code>方法。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>@Override 注解<\/strong>：你可以使用<code>@Override<\/code>注解来明确表示一个方法是重写的方法。这不仅可以提高代码的可读性，还可以让编译器帮你检查是否正确地重写了方法。如果没有正确地重写方法（例如，方法签名不同），编译器会报错。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>方法签名<\/strong>：为了正确地重写一个方法，子类的方法必须具有与父类方法相同的名称和参数。返回类型应该相同，或者是父类方法返回类型的子类型。此外，子类方法的访问级别不能比父类方法的访问级别更严格。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>super关键字<\/strong>：在重写的方法中，你可以使用<code>super<\/code>关键字来调用父类的原始方法。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token keyword\">extends<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token annotation punctuation\">@Override<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">makeSound<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token keyword\">super<\/span><span class=\"token punctuation\">.<\/span><span class=\"token function\">makeSound<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ Call the original method in the superclass<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"In addition, the dog barks\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>类的<code>makeSound<\/code>方法首先调用了<code>Animal<\/code>类的<code>makeSound<\/code>方法，然后再打印出额外的信息。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>重写与重载的区别<\/strong>：<strong>方法重写<\/strong>和<strong>方法重载<\/strong>是Java中两种非常重要的概念，它们都涉及到方法的使用，但是用法和意义有很大的区别。<\/p>\r\n<p>（1）. <strong>方法重写（Override）<\/strong>：方法重写发生在父类和子类之间，当子类需要改变从父类继承的方法的行为时，可以提供一个与父类方法具有相同名称和参数的新方法。重写的方法必须有相同的名称、参数列表和兼容的返回类型，并且访问级别不能比父类方法的访问级别更严格。<\/p>\r\n<p>（2）. <strong>方法重载（Overload）<\/strong>：方法重载发生在同一个类中，当类需要多个功能类似但参数不同的方法时，可以使用相同的方法名，但参数列表必须不同（即参数的类型、顺序或数量不同）。返回类型和访问修饰符可以不同。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">MyClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">myMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token keyword\">int<\/span> x<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span> <span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span> <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">myMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">String<\/span> s<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span> <span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span> <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">myMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token keyword\">int<\/span> x<span class=\"token punctuation\">,<\/span> <span class=\"token class-name\">String<\/span> s<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span> <span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span> <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>myMethod<\/code>方法被重载了三次，每次都有不同的参数列表。<\/p>\r\n<p><strong>构造方法<\/strong>也可以被重载，以便为创建类的新实例提供不同的初始化选项。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">MyClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">MyClass<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span> <span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span> <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">MyClass<\/span><span class=\"token punctuation\">(<\/span><span class=\"token keyword\">int<\/span> x<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span> <span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span> <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token class-name\">MyClass<\/span><span class=\"token punctuation\">(<\/span><span class=\"token keyword\">int<\/span> x<span class=\"token punctuation\">,<\/span> <span class=\"token class-name\">String<\/span> s<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span> <span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span><span class=\"token punctuation\">.<\/span> <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>MyClass<\/code>的构造方法被重载了三次，每次都有不同的参数列表，提供了不同的初始化选项。<\/p>\r\n<p>然而，构造方法不能被重写。在Java中，构造方法是与类名相同的特殊方法，它用于初始化新创建的对象。由于子类不能继承父类的构造方法，所以也就不存在重写构造方法的情况。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<h2 id=\"多态\">多态<\/h2>\r\n<p>多态性是面向对象编程的三大核心特性之一（封装、继承和多态）。在Java中，多态性主要体现在接口和继承上。<\/p>\r\n<p>以下是关于Java多态的一些关键知识点：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>基本概念<\/strong>：多态性是指同一个接口可以有多种实现形式。在Java中，这通常意味着一个父类（或接口）引用可以指向一个子类对象。这个父类引用可以调用在父类中定义的任何方法，如果这些方法在子类中被重写，那么将会执行子类的版本。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>动态方法分派<\/strong>：多态的核心在于动态方法分派，这是Java运行时系统的一部分。当一个方法被调用时，Java运行时系统查看对象的类型，然后运行与该类型关联的方法版本。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token class-name\">Animal<\/span> myPet <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\nmyPet<span class=\"token punctuation\">.<\/span><span class=\"token function\">makeSound<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ Calls Dog's version of makeSound<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，尽管<code>myPet<\/code>的编译时类型是<code>Animal<\/code>，但是它的运行时类型是<code>Dog<\/code>，所以当我们调用<code>myPet.makeSound()<\/code>时，实际上调用的是<code>Dog<\/code>类的<code>makeSound<\/code>方法。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>向上转型和向下转型<\/strong>：在Java中，你可以将一个子类对象赋值给一个父类引用，这被称为向上转型（upcasting），这是完全安全的。然而，你也可以将一个父类引用转型为子类引用，这被称为向下转型（downcasting），但这可能是不安全的，因为如果实际的对象类型并不是你期望的子类类型，那么会发生<code>ClassCastException<\/code>。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token class-name\">Animal<\/span> myPet <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ Upcasting<\/span>\r\n<span class=\"token class-name\">Dog<\/span> myDog <span class=\"token operator\">=<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">)<\/span> myPet<span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ Downcasting<\/span>\r\n<\/code><\/pre>\r\n<\/li>\r\n<li>\r\n<p><strong>抽象类和接口<\/strong>：在Java中，你可以使用抽象类和接口来定义通用的行为，并通过继承抽象类或实现接口来创建具有特定行为的类。抽象类和接口都可以用来实现多态性。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p>以上就是Java多态的基本概念和用法。理解这些概念对于掌握Java编程非常重要。<\/p>\r\n<h2 id=\"封装\">封装<\/h2>\r\n<p>封装是面向对象编程的三大核心特性之一（封装、继承和多态）。在Java中，封装主要体现在类和访问控制上。<\/p>\r\n<p>以下是关于Java封装的一些关键知识点：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>基本概念<\/strong>：封装是一种隐藏类的内部实现细节，只暴露出安全的操作和属性的机制。封装的主要目的是增加安全性和简化编程。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>类和对象<\/strong>：在Java中，类是封装数据（属性）和行为（方法）的主要工具。对象是类的实例，代表了类的一个特定实例。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>访问修饰符<\/strong>：Java提供了四种访问修饰符（private、protected、public和默认（包私有））来控制类成员的可见性。通过正确地使用访问修饰符，可以隐藏类的内部状态，并控制外部代码如何与对象交互。<\/p>\r\n<ul>\r\n<li><strong>private<\/strong>：只有类本身可以访问。<\/li>\r\n<li><strong>protected<\/strong>：类本身、同一包内的其他类和所有子类可以访问。<\/li>\r\n<li><strong>public<\/strong>：任何类都可以访问。<\/li>\r\n<li><strong>默认（包私有）<\/strong>：类本身和同一包内的其他类可以访问。<\/li>\r\n<\/ul>\r\n<\/li>\r\n<li>\r\n<p><strong>getters和setters<\/strong>：在Java中，通常会使用getters（访问器）和setters（修改器）来访问和修改私有变量。这些方法允许你控制如何访问和修改这些变量，例如，你可以在setter中添加验证逻辑。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p>接口和抽象类是Java中重要的结构，它们都可以用于定义类的行为但不能实例化。<\/p>\r\n<h2 id=\"接口与抽象类\">接口与抽象类<\/h2>\r\n<h3 id=\"接口\">接口<\/h3>\r\n<ol>\r\n<li>\r\n<p><strong>基本概念<\/strong>：接口是一种定义一组方法（但不实现）的方式，它只包含常量和抽象方法的声明。接口提供了一种机制，使得类可以遵循特定的协议。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>定义接口<\/strong>：使用<code>interface<\/code>关键字定义接口。接口的所有方法默认都是<code>public<\/code>和<code>abstract<\/code>的，所以这些关键字是可选的。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">interface<\/span> <span class=\"token class-name\">MyInterface<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">void<\/span> <span class=\"token function\">myMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<\/li>\r\n<li>\r\n<p><strong>实现接口<\/strong>：类可以使用<code>implements<\/code>关键字来实现接口，必须提供接口中声明的所有方法的实现。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">MyClass<\/span> <span class=\"token keyword\">implements<\/span> <span class=\"token class-name\">MyInterface<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">myMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token comment\">\/\/ implementation<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<\/li>\r\n<li>\r\n<p><strong>扩展接口<\/strong>：接口可以使用<code>extends<\/code>关键字扩展其他接口。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<p>在Java中，接口主要用于定义一个行为规范，它定义了一组需要被实现的方法。接口可以被类实现（使用<code>implements<\/code>关键字），也可以被其他接口继承（使用<code>extends<\/code>关键字）。实现接口的类需要提供接口中所有方法的具体实现。<\/p>\r\n<p>以下是一个使用接口的例子。假设我们正在编写一个程序，需要处理各种类型的动物。我们可以定义一个<code>Animal<\/code>接口，该接口声明了所有动物都应该有的行为：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">interface<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">void<\/span> <span class=\"token function\">eat<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token keyword\">void<\/span> <span class=\"token function\">move<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>然后我们可以创建具体的动物类（如<code>Dog<\/code>和<code>Bird<\/code>），并实现<code>Animal<\/code>接口：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Dog<\/span> <span class=\"token keyword\">implements<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">eat<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The dog eats dog food.\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">move<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The dog runs.\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n\r\n<span class=\"token keyword\">public<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">Bird<\/span> <span class=\"token keyword\">implements<\/span> <span class=\"token class-name\">Animal<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">eat<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The bird eats bird food.\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">move<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"The bird flies.\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，<code>Dog<\/code>和<code>Bird<\/code>类都实现了<code>Animal<\/code>接口，所以它们都需要提供<code>eat<\/code>和<code>move<\/code>方法的具体实现。这就保证了我们可以在程序中统一处理所有类型的动物，因为我们知道所有的动物都有<code>eat<\/code>和<code>move<\/code>这两个行为。<\/p>\r\n<p>例如，我们可以写一个方法，该方法接受一个<code>Animal<\/code>对象，调用它的<code>eat<\/code>和<code>move<\/code>方法：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">doAnimalThings<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\">Animal<\/span> animal<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    animal<span class=\"token punctuation\">.<\/span><span class=\"token function\">eat<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    animal<span class=\"token punctuation\">.<\/span><span class=\"token function\">move<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>然后我们可以使用这个方法来处理任何类型的动物，无论是<code>Dog<\/code>还是<code>Bird<\/code>：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token class-name\">Dog<\/span> myDog <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Dog<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<span class=\"token class-name\">Bird<\/span> myBird <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Bird<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n\r\n<span class=\"token function\">doAnimalThings<\/span><span class=\"token punctuation\">(<\/span>myDog<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ Prints: \"The dog eats dog food.\" and \"The dog runs.\"<\/span>\r\n<span class=\"token function\">doAnimalThings<\/span><span class=\"token punctuation\">(<\/span>myBird<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">\/\/ Prints: \"The bird eats bird food.\" and \"The bird flies.\"<\/span>\r\n<\/code><\/pre>\r\n<p>这就是接口的一个基本用法：它定义了一种契约，所有实现该接口的类都必须遵守这个契约。这使得我们可以编写更灵活和更通用的代码。<\/p>\r\n<h3 id=\"抽象类\">抽象类<\/h3>\r\n<ol>\r\n<li>\r\n<p><strong>基本概念<\/strong>：抽象类是一种不能实例化的类，它可以包含抽象方法（没有实现）和非抽象方法（有实现）。<\/p>\r\n<\/li>\r\n<li>\r\n<p><strong>定义抽象类<\/strong>：使用<code>abstract<\/code>关键字定义抽象类。例如：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">public<\/span> <span class=\"token keyword\">abstract<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">MyAbstractClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">abstract<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">myAbstractMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>  <span class=\"token comment\">\/\/ abstract method<\/span>\r\n\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">myConcreteMethod<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token comment\">\/\/ implementation<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<\/li>\r\n<li>\r\n<p><strong>扩展抽象类<\/strong>：类可以使用<code>extends<\/code>关键字来扩展抽象类，必须提供抽象类中所有抽象方法的实现。<\/p>\r\n<\/li>\r\n<\/ol>\r\n<h3 id=\"接口抽象类普通类的区别\">接口、抽象类、普通类的区别<\/h3>\r\n<p>接口、抽象类和普通类是Java中三种不同类型的类结构。它们的主要区别如下：<\/p>\r\n<ol>\r\n<li>\r\n<p><strong>接口（Interface）<\/strong>：所有方法都是抽象方法<\/p>\r\n<ul>\r\n<li>接口是一种完全抽象的类型，只能包含公共的抽象方法（默认）和公共静态常量。<\/li>\r\n<li>一个类可以实现多个接口。<\/li>\r\n<li>从Java 8开始，接口可以包含默认方法和静态方法。<\/li>\r\n<li>接口不能包含构造方法。<\/li>\r\n<li>接口不能被实例化。<\/li>\r\n<\/ul>\r\n<\/li>\r\n<li>\r\n<p><strong>抽象类（Abstract Class）<\/strong>：含有抽象方法和普通方法<\/p>\r\n<ul>\r\n<li>抽象类是一种部分抽象的类型，可以包含抽象方法和非抽象方法，以及变量。<\/li>\r\n<li>一个类只能继承一个抽象类。<\/li>\r\n<li>抽象类可以包含构造方法。<\/li>\r\n<li>抽象类不能被实例化，但可以被子类继承，子类必须实现抽象类中的所有抽象方法。<\/li>\r\n<\/ul>\r\n<\/li>\r\n<li>\r\n<p><strong>普通类（Class）<\/strong>：没有抽象方法<\/p>\r\n<ul>\r\n<li>普通类（也称为具体类）是一种完全具体的类型，所有的方法都必须有具体的实现。<\/li>\r\n<li>一个类只能继承一个普通类。<\/li>\r\n<li>普通类可以包含构造方法。<\/li>\r\n<li>普通类可以被实例化。<\/li>\r\n<\/ul>\r\n<\/li>\r\n<\/ol>\r\n<p>总的来说，接口是为了实现多继承，定义共享的公共接口；抽象类是为了封装子类的公共行为，并且提供一些默认行为的实现；而普通类则是为了实现具体的功能。<\/p>\r\n<h2 id=\"内部类与匿名类\">内部类与匿名类<\/h2>\r\n<p>Java 中的内部类和匿名类是两种不同的类类型。以下是关于内部类和匿名类的基本知识：<\/p>\r\n<h3 id=\"内部类\">内部类<\/h3>\r\n<p>内部类（Inner Classes）是定义在另一个类中的类。它们可以访问外部类的所有变量和方法，即使它们被声明为私有的。内部类的主要作用是帮助使代码更加整洁和可读，因为它们可以将相关的类组织在一起。<\/p>\r\n<p>内部类分为两种类型：非静态内部类（也称为成员内部类）和静态内部类。<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">class<\/span> <span class=\"token class-name\">OuterClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">InnerClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token comment\">\/\/ This is a non-static inner class<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n\r\n    <span class=\"token keyword\">static<\/span> <span class=\"token keyword\">class<\/span> <span class=\"token class-name\">StaticInnerClass<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token comment\">\/\/ This is a static inner class<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<h3 id=\"匿名类\">匿名类<\/h3>\r\n<p>匿名类（Anonymous Classes）是一种没有名字的内部类。它们主要用于需要仅使用一次的类，通常用在GUI事件处理或者在需要传递一个对象到某个方法，而该对象不会再被其他地方使用的情况下。<\/p>\r\n<p>匿名类通常在你需要使用一个接口或者抽象类，但又觉得创建一个新的类太过冗余时使用。在创建匿名类的时候，你实际上是在声明并且实例化一个类的同时。<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">new<\/span> <span class=\"token class-name\">InterfaceName<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ methods<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>或者<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">new<\/span> <span class=\"token class-name\">AbstractClassName<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token comment\">\/\/ methods<\/span>\r\n<span class=\"token punctuation\">}<\/span>\r\n<\/code><\/pre>\r\n<p>例如，以下代码创建了一个实现了 Runnable 接口的匿名类的实例：<\/p>\r\n<pre class=\"highlighter-prismjs prismjs-lines-highlighted code-theme-dark language-java\" tabindex=\"0\" highlighted=\"true\"><code class=\"highlighter-prismjs language-java\"><span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Thread<\/span><span class=\"token punctuation\">(<\/span><span class=\"token keyword\">new<\/span> <span class=\"token class-name\">Runnable<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n    <span class=\"token keyword\">public<\/span> <span class=\"token keyword\">void<\/span> <span class=\"token function\">run<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\r\n        <span class=\"token class-name\">System<\/span><span class=\"token punctuation\">.<\/span>out<span class=\"token punctuation\">.<\/span><span class=\"token function\">println<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"Running in a new thread.\"<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n    <span class=\"token punctuation\">}<\/span>\r\n<span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">.<\/span><span class=\"token function\">start<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\r\n<\/code><\/pre>\r\n<p>在这个例子中，我们创建了一个实现了 Runnable 接口的匿名类，并且立即使用它作为参数创建了一个新的 Thread 对象。匿名类的 run 方法被实现以打印一条消息，当新的线程启动时，这个消息就会被打印出来。<\/p>\r\n<p>总的来说，内部类和匿名类都是为了提高代码的整洁性和可读性，使得更容易组织和管理相关的类和接口。<\/p>\r\n\r\n<\/div>",
            "author": "群星",
            "tag": "技术笔记",
            "year": "2023",
            "time": "12-13 22:13:33",
            "pinned": false
        }
    ]
}